<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>עורך סצנת תלת-ממד</title>
    <!-- טעינת Tailwind CSS לעיצוב הממשק -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ... existing styles ... */
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            overflow: hidden; /* מניעת גלילה */
            direction: rtl; /* כיוון מימין לשמאל */
            background-color: #1F2937; /* bg-gray-800 */
        }
        #scene-container {
            width: 100vw;
            height: 100vh;
            background-color: #000000; /* רקע שחור */
            cursor: default;
            position: fixed; /* כדי שהפאנלים יהיו מעל */
            top: 0;
            left: 0;
            z-index: 10; /* מתחת לפאנלים */
        }
        canvas {
            display: block;
        }
        /* סגנון לאובייקט שנבחר */
        .selected-object {
            border: 2px solid #34D399; /* emerald-400 */
            background-color: #374151; /* bg-gray-700 */
        }
        /* עיצוב כפתורי העלאת קובץ */
        .texture-upload-input, .bump-upload-input {
            width: 100%;
            font-size: 0.875rem; /* text-sm */
            color: #D1D5DB; /* text-gray-300 */
        }
        .texture-upload-input::file-selector-button,
        .bump-upload-input::file-selector-button {
            margin-left: 0.5rem; /* file:mr-2 */
            padding: 0.25rem 0.5rem; /* file:py-1 file:px-2 */
            border-radius: 0.25rem; /* file:rounded */
            border-width: 0; /* file:border-0 */
            font-size: 0.875rem; /* file:text-sm */
            font-weight: 600; /* file:font-semibold */
            background-color: #2563EB; /* file:bg-blue-600 */
            color: #ffffff; /* file:text-white */
            cursor: pointer;
        }
        .texture-upload-input::file-selector-button:hover,
        .bump-upload-input::file-selector-button:hover {
            background-color: #1D4ED8; /* hover:file:bg-blue-700 */
        }

        /* הסתרת סרגלי גלילה (Webkit) - כללי */
        .hide-scrollbar::-webkit-scrollbar {
             width: 8px;
        }
        .hide-scrollbar::-webkit-scrollbar-track {
             background: #374151;
             border-radius: 4px;
        }
        .hide-scrollbar::-webkit-scrollbar-thumb {
            background: #4B5563;
            border-radius: 4px;
        }
        .hide-scrollbar::-webkit-scrollbar-thumb:hover {
             background: #6B7280;
        }
        /* הסתרת סרגל גלילה עליון במובייל (Webkit) - הוסר כי אין יותר גלילה */
        /* #top-menu-bar::-webkit-scrollbar { ... } */


        /* סגנון לכפתורי גיזמו פעילים */
        .gizmo-btn.active {
            background-color: #2563EB; /* bg-blue-600 */
        }

        #toggle-light-helpers-btn.active {
            background-color: #2563EB; /* bg-blue-600 */
        }

        /* סגנון לכפתורים מושבתים */
        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* סגנון לתיבת סימון מושבתת */
         input[type="checkbox"]:disabled + label {
            opacity: 0.5;
            cursor: not-allowed;
        }
        input[type="checkbox"]:disabled {
            cursor: not-allowed;
        }
        /* סגנון לכפתורי סימון פעילים */
        .overlay-btn.active {
             border: 2px solid white;
             box-shadow: 0 0 5px white;
        }
    </style>
</head>
<body class="bg-gray-800">

    <!-- סרגל תפריטים עליון - Updated classes -->
    <div id="top-menu-bar" class="fixed top-0 left-0 right-0 z-50 flex flex-wrap justify-center items-center p-2 gap-2 bg-gray-800/70 backdrop-blur-sm shadow-lg">
        <!-- כפתור סצנה (שמור/טען) -->
        <button id="scene-btn" class="p-3 text-white rounded-full hover:bg-gray-700 transition flex-shrink-0" title="סצנה">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3l-4-4-4 4zM8 7V5c0-1.1.9-2 2-2h4a2 2 0 012 2v2M8 7h8"></path></svg>
        </button>
        <!-- כפתור תאורה -->
        <button id="lighting-btn" class="p-3 text-white rounded-full hover:bg-gray-700 transition flex-shrink-0" title="תאורה">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m12.728 0l-.707.707M12 21v-1m0-16a9 9 0 11-9 9h4.673c.11.02.22.04.33.06A9 9 0 0112 3z"></path></svg>
        </button>
        <!-- כפתור הצג/הסתר עזרי תאורה -->
        <button id="toggle-light-helpers-btn" class="p-3 text-white rounded-full hover:bg-gray-700 transition active flex-shrink-0" title="הצג/הסתר עזרי תאורה">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
        </button>
        <!-- כפתור אובייקטים -->
        <button id="objects-btn" class="p-3 text-white rounded-full hover:bg-gray-700 transition flex-shrink-0" title="אובייקטים">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16"></path></svg>
        </button>

        <!-- קו הפרדה -->
        <div class="border-l border-gray-600 h-10 my-auto flex-shrink-0"></div>

        <!-- כפתורי היסטוריה -->
        <button id="undo-btn" class="p-3 text-white rounded-full hover:bg-gray-700 transition flex-shrink-0" title="בטל (Ctrl+Z)" disabled>
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
        </button>
        <button id="redo-btn" class="p-3 text-white rounded-full hover:bg-gray-700 transition flex-shrink-0" title="בצע שוב (Ctrl+Y)" disabled>
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>
        </button>

        <!-- קו הפרדה -->
        <div class="border-l border-gray-600 h-10 my-auto flex-shrink-0"></div>

        <!-- כפתורי גיזמו -->
        <button id="translate-btn" class="gizmo-btn p-3 text-white rounded-full hover:bg-gray-700 transition active flex-shrink-0" title="הזזה (W)">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 4H3v3m0-3l4 4M21 3h-7v3m7-3l-4 4M3 21h7v-3M3 21l4-4m14 4h-7v-3m7 3l-4-4"></path></svg>
        </button>
        <button id="rotate-btn" class="gizmo-btn p-3 text-white rounded-full hover:bg-gray-700 transition flex-shrink-0" title="סיבוב (E)">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5">
              <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 11.667 0l3.181-3.183m-11.667-1.343a8.25 8.25 0 0 1-1.12-3.832 8.25 8.25 0 0 1 1.12-3.832 8.25 8.25 0 0 1 3.833-1.12 8.25 8.25 0 0 1 3.833 1.12 8.25 8.25 0 0 1 1.12 3.832 8.25 8.25 0 0 1-1.12 3.832 8.25 8.25 0 0 1-3.833 1.12 8.25 8.25 0 0 1-3.833-1.12Z" />
            </svg>
        </button>
        <button id="scale-btn" class="gizmo-btn p-3 text-white rounded-full hover:bg-gray-700 transition flex-shrink-0" title="גודל (R)">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8V5h3m12 0h3v3m0 11v3h-3m-12 0H3v-3"></path></svg>
        </button>

        <!-- קו הפרדה חדש -->
        <div class="border-l border-gray-600 h-10 my-auto flex-shrink-0"></div>

        <!-- כפתורי קואליציה ואופוזיציה -->
        <button id="coalition-btn" class="px-4 py-2 text-white rounded-full bg-blue-600 hover:bg-blue-700 transition text-sm font-semibold flex-shrink-0" title="קואליציה">
            קואליציה
        </button>
        <button id="opposition-btn" class="px-4 py-2 text-white rounded-full bg-orange-600 hover:bg-orange-700 transition text-sm font-semibold flex-shrink-0" title="אופוזיציה">
            אופוזיציה
        </button>

        <!-- כפתור מחיקה -->
        <button id="delete-btn" class="p-3 text-white rounded-full hover:bg-red-600 transition flex-shrink-0" title="מחק (Delete)">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
        </button>
         <!-- מרווח סיום לגלילה במובייל - הוסר כי אין גלילה -->
    </div>


    <!-- פאנלים צפים - Adjusted top margin dynamically via JS -->
    <div id="scene-panel" class="fixed top-20 right-4 w-11/12 max-w-xs bg-gray-900/80 backdrop-blur-sm text-white z-40 p-4 sm:p-6 rounded-lg shadow-xl hidden flex flex-col max-h-[calc(100vh-6rem)]">
        <div class="p-0 md:p-0 pb-4 flex justify-between items-center draggable-handle cursor-move sticky top-0 bg-gray-900/80 md:bg-transparent z-10">
            <h2 class="text-xl font-semibold text-white">בקרי סצנה</h2>
            <button class="p-1 text-gray-400 hover:text-white close-panel-btn">
                 <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="overflow-y-auto pt-0 hide-scrollbar flex-grow">
            <!-- Updated Scene Panel Content -->
            <div class="space-y-3">
                <button id="save-scene-btn" class="w-full px-4 py-2 bg-green-600 hover:bg-green-700 rounded text-white transition-colors">שמור סצנה</button>
                <div>
                    <label for="load-scene-input" class="block text-sm font-medium text-gray-300 mb-1">טען סצנה מקובץ (JSON)</label>
                    <input type="file" id="load-scene-input" class="texture-upload-input" accept=".json">
                </div>
                <hr class="border-gray-600">
                <button id="load-preset-btn" class="w-full px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded text-white transition-colors">טען סצנת הדגמה (kneeset_28)</button>
                <button id="reset-scene-btn" class="w-full px-4 py-2 bg-yellow-600 hover:bg-yellow-700 rounded text-white transition-colors">אפס לסצנת ברירת מחדל</button>
            </div>
        </div>
    </div>

    <!-- ... rest of the panels ... -->
    <div id="lighting-panel" class="fixed top-20 right-4 w-11/12 max-w-xs bg-gray-900/80 backdrop-blur-sm text-white z-40 rounded-lg shadow-xl hidden flex flex-col max-h-[calc(100vh-6rem)]">
        <div class="p-0 md:p-0 pb-4 flex justify-between items-center draggable-handle cursor-move sticky top-0 bg-gray-900/80 md:bg-transparent z-10">
            <h2 class="text-xl font-semibold text-white">בקרי תאורה</h2>
            <button class="p-1 text-gray-400 hover:text-white close-panel-btn">
                 <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="overflow-y-auto pt-0 hide-scrollbar flex-grow">
            <!-- רשימת מנורות -->
            <h3 class="text-lg font-medium text-gray-200 mb-2">מנורות בסצנה</h3>
            <div id="light-list" class="space-y-2 mb-4 max-h-40 overflow-y-auto hide-scrollbar">
                <div class="text-gray-400 text-sm">אין מנורות נקודתיות להצגה.</div>
            </div>
             <!-- כפתור הוספת מנורה -->
             <button id="add-point-light-btn" class="w-full px-4 py-2 mb-4 bg-blue-600 hover:bg-blue-700 rounded text-white transition-colors">הוסף מנורה נקודתית</button>
        </div>
    </div>

    <div id="objects-panel" class="fixed top-20 right-4 w-11/12 max-w-xs bg-gray-900/80 backdrop-blur-sm text-white z-40 rounded-lg shadow-xl hidden flex flex-col max-h-[calc(100vh-6rem)] md:h-[70vh]">
         <div class="p-0 md:p-0 pb-4 flex justify-between items-center draggable-handle cursor-move sticky top-0 bg-gray-900/80 md:bg-transparent z-10">
            <h2 class="text-xl font-semibold text-white">אובייקטים בסצנה</h2>
            <button class="p-1 text-gray-400 hover:text-white close-panel-btn">
                 <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div id="object-list" class="space-y-4 overflow-y-auto pt-0 hide-scrollbar flex-grow">
            <!-- הרשימה תתמלא באופן דינמי על ידי JavaScript -->
            <div class="text-gray-400">טוען מודל...</div>
        </div>
    </div>

    <!-- פאנל אובייקט בודד (שמאל) -->
    <div id="single-object-panel" class="fixed top-20 left-4 w-11/12 max-w-xs bg-gray-900/80 backdrop-blur-sm text-white z-40 rounded-lg shadow-xl hidden flex flex-col max-h-[calc(100vh-6rem)] md:top-1/2 md:left-5 md:-translate-y-1/2 md:max-h-[80vh]">
        <div class="p-0 md:p-0 pb-2 flex justify-between items-center draggable-handle cursor-move sticky top-0 bg-gray-900/80 md:bg-transparent z-10">
             <h3 id="single-object-title-static" class="font-semibold text-lg text-white truncate">אובייקט</h3>
             <button id="close-single-panel-btn" class="p-1 text-gray-400 hover:text-white">
                 <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
             </button>
        </div>
        <div id="single-object-controls" class="overflow-y-auto pt-0 hide-scrollbar flex-grow p-4 sm:p-6">
            <!-- התוכן יוכנס לכאן דינמית -->
        </div>
    </div>

    <!-- פאנל מנורה נקודתית (שמאל) -->
    <div id="point-light-panel" class="fixed top-20 left-4 w-11/12 max-w-xs bg-gray-900/80 backdrop-blur-sm text-white z-40 rounded-lg shadow-xl hidden flex flex-col max-h-[calc(100vh-6rem)] md:top-1/2 md:left-5 md:-translate-y-1/2 md:max-h-[80vh]">
        <div class="p-0 md:p-0 pb-2 flex justify-between items-center draggable-handle cursor-move sticky top-0 bg-gray-900/80 md:bg-transparent z-10">
             <h3 id="point-light-title" class="font-semibold text-lg text-white truncate">מנורה נקודתית</h3>
             <button id="close-point-light-panel-btn" class="p-1 text-gray-400 hover:text-white">
                 <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
             </button>
        </div>
        <div id="point-light-controls" class="overflow-y-auto pt-0 space-y-4 hide-scrollbar flex-grow p-4 sm:p-6">
             <button
                class="duplicate-btn w-full px-3 py-1 text-sm bg-blue-600 hover:bg-blue-700 rounded text-white transition-colors"
                data-object-id=""> <!-- ID יתעדכן דינמית -->
                שכפל מנורה
             </button>
             <div>
                <label for="pl-intensity-slider" class="text-sm text-gray-300">עוצמה (<span id="pl-intensity-value">100</span>)</label>
                <input type="range" class="w-full point-light-control" id="pl-intensity-slider" min="0" max="150" step="1" value="100">
             </div>
             <div>
                <label for="pl-distance-slider" class="text-sm text-gray-300">טווח (<span id="pl-distance-value">100</span>)</label>
                <input type="range" class="w-full point-light-control" id="pl-distance-slider" min="0" max="100" step="0.5" value="100">
             </div>
             <div>
                <label for="pl-color-picker" class="text-sm text-gray-300">צבע</label>
                <input type="color" class="w-full h-10 p-1 bg-gray-700 border border-gray-600 rounded cursor-pointer point-light-control" id="pl-color-picker" value="#ffffff">
             </div>
             <hr class="border-gray-600">
             <div class="flex items-center space-x-2 space-x-reverse">
                 <input type="checkbox" class="point-light-control form-checkbox h-5 w-5 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500" id="pl-cast-shadow-checkbox">
                 <label for="pl-cast-shadow-checkbox" class="text-sm text-gray-300">הטל צל</label>
             </div>
             <div>
                 <!-- ערך התחלתי אמצעי -->
                <label for="pl-shadow-bias-slider" class="text-sm text-gray-300">היסט צל (Bias)</label>
                <input type="range" class="w-full point-light-control" id="pl-shadow-bias-slider" min="-0.01" max="0.01" step="0.0001" value="0">
             </div>
             <div>
                 <!-- ערך התחלתי אמצעי -->
                <label for="pl-shadow-normal-bias-slider" class="text-sm text-gray-300">היסט נורמל (Normal Bias)</label>
                <input type="range" class="w-full point-light-control" id="pl-shadow-normal-bias-slider" min="0" max="0.1" step="0.001" value="0.05">
             </div>
             <p class="text-gray-400 text-sm">הזז את המנורה באמצעות הגיזמו.</p>
        </div>
    </div>


    <!-- קונטיינר לסצנת ה-Three.js -->
    <div id="scene-container"></div>


    <!-- טעינת Three.js וספריות עזר -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "tween": "https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@23.1.2/dist/tween.esm.js",
                "fflate": "https://cdn.jsdelivr.net/npm/fflate@0.8.1/esm/browser.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import * as TWEEN from 'tween';
        import { AnimationMixer } from 'three';

        // ... existing variables ...
        let scene, camera, renderer, controls;
        let composer;
        let transformControls; // Moved declaration here
        let sceneObjects = [];
        let pointLights = [];
        let lightHelpersMap = new Map();
        let lightRangeIndicator = null;
        let knessetBounds = null;
        const boundsPadding = 2;

        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 20;
        let transformBeforeState = null;

        const MAX_SHADOW_CASTING_POINT_LIGHTS = 4;
        const KNESSET_MODEL_URL = 'https://raw.githubusercontent.com/orengamchi/kenesset_ai/main/kenesset_ai.glb';
        const CHAIR_MODEL_URL = 'https://raw.githubusercontent.com/orengamchi/kenesset_ai/main/seat_big.glb';
        const CHAIR_UPHOLSTERY_MATERIAL_NAME = 'kneset_chair_Color_C'; // Added constant for upholstery material name

        const FBX_MODEL_URL = 'https://raw.githubusercontent.com/orengamchi/avatari/main/yair%20n.fbx';
        const AMSALEM_MODEL_URL = 'https://raw.githubusercontent.com/orengamchi/avatari/main/amsalem.fbx';
        const DERI_MODEL_URL = 'https://raw.githubusercontent.com/orengamchi/avatari/main/deri.fbx';
        const ANIMATION_URL = 'https://raw.githubusercontent.com/orengamchi/avatari/main/Sitting%20Clap.fbx';
        let sittingClapAnimation = null;
        let mixers = [];
        const clock = new THREE.Clock();


        const loadingManager = new THREE.LoadingManager();
        const textureLoader = new THREE.TextureLoader();
        const gltfLoader = new GLTFLoader(loadingManager);
        const fbxLoader = new FBXLoader(loadingManager);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let globalObjectCounter = 1;
        let selectedObjects = [];
        let areLightHelpersVisible = true;

        const PRESET_SCENE_URL = 'https://raw.githubusercontent.com/orengamchi/kenesset_ai/main/kneeset_28.json'; // Added preset URL

        // Cache for overlay materials
        const overlayMaterials = {
            coalition: null,
            opposition: null
        };

        // DOM Elements
        const sceneContainer = document.getElementById('scene-container');
        const sidebarList = document.getElementById('object-list');
        const lightListContainer = document.getElementById('light-list');
        const saveBtn = document.getElementById('save-scene-btn');
        const loadInput = document.getElementById('load-scene-input');
        const addPointLightBtn = document.getElementById('add-point-light-btn');
        const sceneBtn = document.getElementById('scene-btn');
        const lightingBtn = document.getElementById('lighting-btn');
        const toggleLightHelpersBtn = document.getElementById('toggle-light-helpers-btn');
        const objectsBtn = document.getElementById('objects-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const translateBtn = document.getElementById('translate-btn');
        const rotateBtn = document.getElementById('rotate-btn');
        const scaleBtn = document.getElementById('scale-btn');
        const gizmoButtons = [translateBtn, rotateBtn, scaleBtn];
        const deleteBtn = document.getElementById('delete-btn');
        const scenePanel = document.getElementById('scene-panel');
        const lightingPanel = document.getElementById('lighting-panel');
        const objectsPanel = document.getElementById('objects-panel');
        const singleObjectPanel = document.getElementById('single-object-panel');
        const closeSinglePanelBtn = document.getElementById('close-single-panel-btn');
        const pointLightPanel = document.getElementById('point-light-panel');
        const closePointLightPanelBtn = document.getElementById('close-point-light-panel-btn');
        const plIntensitySlider = document.getElementById('pl-intensity-slider');
        const plDistanceSlider = document.getElementById('pl-distance-slider');
        const plIntensityValueSpan = document.getElementById('pl-intensity-value');
        const plDistanceValueSpan = document.getElementById('pl-distance-value');
        const plColorPicker = document.getElementById('pl-color-picker');
        const plCastShadowCheckbox = document.getElementById('pl-cast-shadow-checkbox');
        const plShadowBiasSlider = document.getElementById('pl-shadow-bias-slider');
        const plShadowNormalBiasSlider = document.getElementById('pl-shadow-normal-bias-slider');
        const coalitionBtn = document.getElementById('coalition-btn');
        const loadPresetBtn = document.getElementById('load-preset-btn'); // Added preset button
        const resetSceneBtn = document.getElementById('reset-scene-btn'); // Added reset button
        const allPanels = [scenePanel, lightingPanel, objectsPanel, singleObjectPanel, pointLightPanel];

        // --- Initialization ---
        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // רקע שחור

            camera = new THREE.PerspectiveCamera(75, sceneContainer.clientWidth / sceneContainer.clientHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.toneMapping = THREE.ReinhardToneMapping;
            sceneContainer.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 2, 0);
            controls.maxPolarAngle = Math.PI / 2.05;

            // Initialize transformControls EARLIER
            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', (event) => {
                controls.enabled = !event.value;
                if (event.value) {
                    if (transformControls.object) {
                        transformBeforeState = { position: transformControls.object.position.clone(), rotation: transformControls.object.rotation.clone(), scale: transformControls.object.scale.clone() };
                    }
                } else if (transformBeforeState && transformControls.object) {
                    addHistory({ type: 'transform', object: transformControls.object, before: transformBeforeState, after: { position: transformControls.object.position.clone(), rotation: transformControls.object.rotation.clone(), scale: transformControls.object.scale.clone() } });
                    transformBeforeState = null;
                }
            });
            transformControls.addEventListener('objectChange', () => {
                if (transformControls.object) {
                    const actualLight = lightHelpersMap.get(transformControls.object);
                    if (actualLight) {
                        actualLight.position.copy(transformControls.object.position);
                        if (actualLight instanceof THREE.PointLight) updateRangeIndicator();
                    }
                    const parentModel = transformControls.object;
                    if (parentModel && parentModel.userData.transform) {
                         parentModel.userData.transform.position.copy(parentModel.position);
                         parentModel.userData.transform.rotation.copy(parentModel.rotation);
                         parentModel.userData.transform.scale.copy(parentModel.scale);
                    }
                }
            });
            scene.add(transformControls);

            // Now reset the scene, transformControls is defined
            resetSceneToDefault(false); // Initialize with default scene without adding to history

            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera); composer.addPass(renderPass);
            const outputPass = new OutputPass(); composer.addPass(outputPass);

            window.addEventListener('resize', onWindowResize);
            onWindowResize(); // Call once initially to set correct panel positions

            // --- Event Listeners ---
            // ... rest of the event listeners ...
            sidebarList.addEventListener('click', onSidebarClick);
            lightListContainer.addEventListener('click', onLightListClick);
            addPointLightBtn.addEventListener('click', handleAddPointLight);

            sceneContainer.addEventListener('click', (e) => {
                 const isClickOnGizmo = transformControls.dragging;
                 const isClickOnCanvas = e.target === renderer.domElement;

                 if (isClickOnCanvas && !isClickOnGizmo) {
                     const rect = renderer.domElement.getBoundingClientRect();
                     mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                     mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                     raycaster.setFromCamera(mouse, camera);
                     const intersects = raycaster.intersectObjects(sceneObjects.map(o => o.mesh), false);

                     if (intersects.length > 0) {
                         let intersectedSceneObject = null;
                         for (const intersect of intersects) {
                             intersectedSceneObject = sceneObjects.find(obj => obj.mesh === intersect.object);
                             if (intersectedSceneObject) break;
                         }
                         if (intersectedSceneObject) {
                             selectObject(intersectedSceneObject, e);
                         }
                     } else if (!(e.ctrlKey || e.metaKey)) {
                         deselectObject();
                         closeSinglePanels();
                     }
                 }
            });
             sceneContainer.addEventListener('dblclick', onDoubleClick);

            saveBtn.addEventListener('click', saveScene);
            loadInput.addEventListener('change', loadSceneFromFile); // Changed function name
            loadPresetBtn.addEventListener('click', loadPresetScene); // Added listener
            resetSceneBtn.addEventListener('click', () => resetSceneToDefault()); // Added listener

            sceneBtn.addEventListener('click', (e) => { e.stopPropagation(); openPanel(scenePanel); });
            lightingBtn.addEventListener('click', (e) => { e.stopPropagation(); openPanel(lightingPanel); });
            objectsBtn.addEventListener('click', (e) => { e.stopPropagation(); openPanel(objectsPanel); });
            toggleLightHelpersBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleLightHelpers(); });
            coalitionBtn.addEventListener('click', (e) => { e.stopPropagation(); loadCoalitionModels(); });

            document.querySelectorAll('.close-panel-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const panel = e.target.closest('.fixed');
                    if (panel) panel.classList.add('hidden');
                });
            });
            undoBtn.addEventListener('click', (e) => { e.stopPropagation(); undo(); });
            redoBtn.addEventListener('click', (e) => { e.stopPropagation(); redo(); });
            deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteSelected(); });
            translateBtn.addEventListener('click', (e) => { e.stopPropagation(); setGizmoMode('translate'); });
            rotateBtn.addEventListener('click', (e) => { e.stopPropagation(); setGizmoMode('rotate'); });
            scaleBtn.addEventListener('click', (e) => { e.stopPropagation(); setGizmoMode('scale'); });
            closeSinglePanelBtn.addEventListener('click', (e) => { e.stopPropagation(); singleObjectPanel.classList.add('hidden'); });
            closePointLightPanelBtn.addEventListener('click', (e) => { e.stopPropagation(); pointLightPanel.classList.add('hidden'); });
            singleObjectPanel.addEventListener('click', onSinglePanelClick);
            singleObjectPanel.addEventListener('change', onSinglePanelChange);
            singleObjectPanel.addEventListener('input', onSinglePanelChange); // Keep input for sliders maybe
            pointLightPanel.addEventListener('click', onPointLightPanelClick);
            pointLightPanel.addEventListener('input', onPointLightPanelChange);
            pointLightPanel.addEventListener('change', onPointLightPanelChange);

            makeDraggable(scenePanel);
            makeDraggable(lightingPanel);
            makeDraggable(objectsPanel);
            makeDraggable(singleObjectPanel);
            makeDraggable(pointLightPanel);

            allPanels.forEach(panel => { panel.addEventListener('click', (e) => e.stopPropagation()); });
            window.addEventListener('keydown', onKeyDown);
            updateHistoryButtons();
            toggleLightHelpersBtn.classList.toggle('active', areLightHelpersVisible);
        }

        // --- Light Creation ---
        // ... existing createPointLight ...
         function createPointLight(position, intensity, distance = 100, color = 0xffffff, castShadow = false, shadowBias = 0, shadowNormalBias = 0.05) {
             const currentShadowCasters = pointLights.filter(pl => pl.light.castShadow).length;
             let actualCastShadow = castShadow;
             if (castShadow && currentShadowCasters >= MAX_SHADOW_CASTING_POINT_LIGHTS) {
                 actualCastShadow = false;
                 // אל תציג אזהרה עבור מנורות התחלתיות שנוספו מעבר למגבלה
                 // console.warn(`מגבלת מנורות מטילות צל (${MAX_SHADOW_CASTING_POINT_LIGHTS}) הושגה. המנורה החדשה לא תטיל צל.`);
             }

            const pointLight = new THREE.PointLight(color, intensity, distance);
            pointLight.position.copy(position);
            pointLight.castShadow = actualCastShadow;
            pointLight.shadow.bias = shadowBias;
            pointLight.shadow.normalBias = shadowNormalBias;
            pointLight.shadow.mapSize.width = 512; pointLight.shadow.mapSize.height = 512;
            pointLight.shadow.camera.near = 0.5; pointLight.shadow.camera.far = 50;
            scene.add(pointLight);

            const helperGeo = new THREE.SphereGeometry(0.3, 16, 8);
            const helperMat = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
            const helperMesh = new THREE.Mesh(helperGeo, helperMat);
            const lightIndex = pointLights.length + 1;
            helperMesh.name = `PointLight Helper ${lightIndex}`;
            helperMesh.position.copy(pointLight.position);
            helperMesh.visible = areLightHelpersVisible;
            scene.add(helperMesh);

            lightHelpersMap.set(helperMesh, pointLight);
            helperMesh.userData.transform = { position: helperMesh.position.clone(), rotation: helperMesh.rotation.clone(), scale: helperMesh.scale.clone() };

            const sceneObjectData = { id: helperMesh.uuid, stableId: helperMesh.uuid, name: `מנורה נקודתית ${lightIndex}`, mesh: helperMesh, originalMaterial: helperMat.clone(), parentModel: helperMesh, isLightHelper: true, lightType: 'point' };
            sceneObjects.push(sceneObjectData);
            pointLights.push({ light: pointLight, helper: helperMesh, data: sceneObjectData });

            populateLightList();
            return { light: pointLight, helper: helperMesh, data: sceneObjectData };
        }

        function handleAddPointLight() {
             const position = new THREE.Vector3(Math.random() * 10 - 5, 5, Math.random() * 10 - 5);
             const { light, helper, data } = createPointLight(position, 100, 100, 0xffffff, false, 0, 0.05);
             addHistory({ type: 'addLight', lightType: 'point', addedLight: light, addedHelper: helper, addedSceneObjectData: data });
        }


        // ... existing loadAnimation, getModelNameLogic, loadCoalitionModels, playAnimationOnModel ...
        async function loadAnimation(url) {
            return new Promise((resolve, reject) => {
                fbxLoader.load(url, (object) => {
                    if (object.animations && object.animations.length > 0) {
                        resolve(object.animations[0]);
                    } else {
                        reject(new Error(`No animations found in ${url}`));
                    }
                }, undefined, (error) => {
                    reject(error);
                });
            });
        }
        function getModelNameLogic(url) {

             if (url.toLowerCase().endsWith('.fbx')) {
                 if (url.includes('yair')) return () => "מודל יאיר";
                 if (url.includes('amsalem')) return () => "מודל אמסלם";
                 if (url.includes('deri')) return () => "מודל דרעי";
                 return () => "מודל FBX";
             }
            if (url === CHAIR_MODEL_URL) {
                // Return detailed names for chair parts
                return (objectName, material) => {
                    const matName = Array.isArray(material) ? (material[0] ? material[0].name : objectName) : (material.name || objectName);
                    if (matName === CHAIR_UPHOLSTERY_MATERIAL_NAME) return 'ריפוד כיסא'; // Specific name for upholstery
                    if (matName === 'wheels') return 'גלגלי כיסא';
                    if (matName === 'chair_low_seat_BaseColor') return 'בסיס כיסא';
                    // Fallback name for the whole chair model if needed, though individual parts are preferred
                    return 'כיסא';
                };
            }
             if (url === KNESSET_MODEL_URL) {
                 // זיהוי הפאנלים האדומים גם כאן
                 return (objectName, material) => {
                     const matName = Array.isArray(material) ? (material[0] ? material[0].name : objectName) : (material.name || objectName);
                     if (matName && matName.toLowerCase().includes('mat_primitive1')) {
                         return 'פאנל LED';
                     }
                     return "מודל הכנסת";
                 };
             }
            return () => null; // Default null name
        }
        async function loadCoalitionModels() {
            console.log('טוען מודלים של קואליציה...');
            coalitionBtn.disabled = true;
            coalitionBtn.textContent = 'טוען...';

            try {
                if (!sittingClapAnimation) {
                    console.log('טוען אנימציה...');
                    sittingClapAnimation = await loadAnimation(ANIMATION_URL);
                    console.log('אנימציה נטענה.');
                }

                const modelsToLoad = [
                    { url: FBX_MODEL_URL, options: { scale: new THREE.Vector3(0.01, 0.01, 0.01), position: new THREE.Vector3(-3, 0, -3), nameLogic: getModelNameLogic(FBX_MODEL_URL), isLocked: false } },
                    { url: AMSALEM_MODEL_URL, options: { scale: new THREE.Vector3(0.01, 0.01, 0.01), position: new THREE.Vector3(-1, 0, -3), nameLogic: getModelNameLogic(AMSALEM_MODEL_URL), isLocked: false } },
                    { url: DERI_MODEL_URL, options: { scale: new THREE.Vector3(0.01, 0.01, 0.01), position: new THREE.Vector3(1, 0, -3), nameLogic: getModelNameLogic(DERI_MODEL_URL), isLocked: false } }
                ];

                for (const modelData of modelsToLoad) {
                    const newModel = await loadFBXModel(modelData.url, modelData.options);

                    if (sittingClapAnimation) {
                        playAnimationOnModel(newModel, sittingClapAnimation);
                    }
                }
                console.log('מודלים של קואליציה נטענו והאנימציה הופעלה.');
                populateSidebar();
            } catch (error) {
                console.error('שגיאה בטעינת מודלים של קואליציה או אנימציה:', error);
            } finally {
                coalitionBtn.disabled = false;
                coalitionBtn.textContent = 'קואליציה';
            }
        }
        function playAnimationOnModel(model, animationClip) {
            const mixer = new AnimationMixer(model);
            const action = mixer.clipAction(animationClip);
            action.play();
            mixers.push(mixer);
            model.userData.mixer = mixer;
        }


        // --- Model Loading ---
        // ... existing loadAllModels, loadGLBModel, loadFBXModel ...
         async function loadAllModels(modelsToLoad = null) {
            mixers = []; // Clear mixers on full reload

            // Remove existing non-light models
            const modelsToRemove = sceneObjects.filter(obj => obj.parentModel && !obj.isLightHelper).map(obj => obj.parentModel);
            const uniqueModelsToRemove = [...new Set(modelsToRemove)];
            uniqueModelsToRemove.forEach(model => scene.remove(model));

            // Filter out non-light objects, keep light helpers
            sceneObjects = sceneObjects.filter(obj => obj.isLightHelper);

            // Detach controls if attached to a model being removed
            if (transformControls.object && uniqueModelsToRemove.includes(transformControls.object)) {
                 transformControls.detach();
            }
            // deselectObject(); // Deselect everything
            closeSinglePanels();
            knessetBounds = null; // Recalculate bounds

            let modelList;
            if (modelsToLoad) {
                modelList = modelsToLoad.map(modelData => ({
                    url: modelData.url,
                    options: {
                        scale: new THREE.Vector3().fromArray(modelData.transform.scale),
                        position: new THREE.Vector3().fromArray(modelData.transform.position),
                        rotation: new THREE.Euler().fromArray(modelData.transform.rotation),
                        nameLogic: getModelNameLogic(modelData.url),
                        isLocked: modelData.url === KNESSET_MODEL_URL
                    },
                    materials: modelData.materials || {}, // Ensure materials object exists
                    hasAnimation: modelData.hasAnimation,
                    overlayState: modelData.overlayState || null // Load overlay state
                }));
            } else {
                sidebarList.innerHTML = `<div class="text-gray-400">טוען מודלים...</div>`;
                modelList = [
                     { url: KNESSET_MODEL_URL, options: { scale: new THREE.Vector3(0.5, 0.5, 0.5), position: new THREE.Vector3(0, 0, 0), nameLogic: getModelNameLogic(KNESSET_MODEL_URL), isLocked: true }, materials: {}, hasAnimation: false, overlayState: null },
                    { url: CHAIR_MODEL_URL, options: { scale: new THREE.Vector3(3, 3, 3), position: new THREE.Vector3(0, 0, 0), nameLogic: getModelNameLogic(CHAIR_MODEL_URL), isLocked: false }, materials: {}, hasAnimation: false, overlayState: null }
                ];
            }
            try {
                 let animationClip = null;
                 if (modelList.some(m => m.hasAnimation)) {
                     try {
                         animationClip = await loadAnimation(ANIMATION_URL);
                         sittingClapAnimation = animationClip;
                     } catch (animError) {
                         console.error("Failed to load animation:", animError);
                     }
                 }


                for (const modelData of modelList) {
                     let newModel;
                     if (modelData.url.toLowerCase().endsWith('.glb') || modelData.url.toLowerCase().endsWith('.gltf')) {
                         newModel = await loadGLBModel(modelData.url, modelData.options);
                     } else if (modelData.url.toLowerCase().endsWith('.fbx')) {
                         newModel = await loadFBXModel(modelData.url, modelData.options);
                     } else {
                         console.warn(`Unsupported model format: ${modelData.url}`);
                         continue;
                     }

                     // Apply saved rotation AFTER loading
                    if (modelData.options.rotation) {
                         newModel.rotation.copy(modelData.options.rotation);
                         if (newModel.userData.transform) {
                            newModel.userData.transform.rotation.copy(newModel.rotation);
                         }
                    }

                     if (modelData.url === KNESSET_MODEL_URL) {
                         knessetBounds = new THREE.Box3().setFromObject(newModel);
                         console.log("Knesset Bounds Calculated:", knessetBounds);
                     }

                     // Apply saved materials
                    for (const stableId in modelData.materials) {
                         const matProps = modelData.materials[stableId];
                         const targetObject = sceneObjects.find(obj => obj.stableId === stableId && obj.parentModel === newModel);
                         if (targetObject) {
                             const materialToChange = getMaterialToChange(targetObject.mesh);
                             const applyLoadedProps = async (mat) => { // Make async
                                 mat.color.set(matProps.color.startsWith('#') ? matProps.color : "#" + matProps.color);
                                 if (matProps.roughness !== undefined) mat.roughness = matProps.roughness;
                                 if (matProps.metalness !== undefined) mat.metalness = matProps.metalness;
                                 if (matProps.opacity !== undefined) {
                                     mat.opacity = matProps.opacity;
                                     mat.transparent = matProps.opacity < 1;
                                 }
                                 if (matProps.emissiveIntensity !== undefined) {
                                    mat.emissiveIntensity = matProps.emissiveIntensity;
                                    if(targetObject.name === 'פאנל LED' && mat.emissiveIntensity > 0 && mat.emissive.getHexString() === '000000') {
                                        mat.emissive.setHex(0xFF0000);
                                    }
                                 }
                                 mat.aoMap = null; // Ensure AO map isn't interfering from original load

                                 // Await texture/bump loading before setting needsUpdate
                                 let textureApplied = false;
                                 let bumpApplied = false;
                                 if (matProps.textureDataUrl) {
                                     await applyTextureFromDataUrl(targetObject, matProps.textureDataUrl, false); // Apply without adding history again
                                     textureApplied = true;
                                 }
                                 if (matProps.bumpDataUrl) {
                                     await applyBumpMapFromDataUrl(targetObject, matProps.bumpDataUrl, false); // Apply without adding history again
                                     bumpApplied = true;
                                 }

                                  // Reset base color if texture was loaded
                                 if (textureApplied) {
                                     mat.color.set(0xffffff);
                                 }


                                 // Store original properties for potential overlay later
                                 mat.userData.originalLoadedProps = { ...matProps };


                                 mat.needsUpdate = true;
                             };

                            if (Array.isArray(materialToChange)) {
                                 for(const mat of materialToChange) await applyLoadedProps(mat); // Use await with for...of
                            } else if(materialToChange) {
                                 await applyLoadedProps(materialToChange); // Use await
                            }

                            // Apply overlay state AFTER base materials are set
                            if (modelData.url === CHAIR_MODEL_URL && modelData.overlayState && targetObject.name === 'ריפוד כיסא') {
                                applyChairOverlay(targetObject, modelData.overlayState, false); // Apply overlay without adding history
                            }

                         } else {
                            console.warn(`Could not find object with stableId ${stableId} in model ${modelData.url} to apply materials.`);
                         }
                    }

                    // Store overlay state on the parent model's userData if it's a chair
                    if(modelData.url === CHAIR_MODEL_URL) {
                         newModel.userData.overlayState = modelData.overlayState || null;
                    }


                     if (modelData.hasAnimation && animationClip) {
                         playAnimationOnModel(newModel, animationClip);
                     }
                }
                console.log("All models loaded successfully.");
                populateSidebar(); // Populate sidebar after models are processed
            } catch (error) {
                console.error("Failed to load one or more models:", error);
                sidebarList.innerHTML = `<div class="text-red-400">שגיאה בטעינת מודלים.</div>`;
            }
        }
        function loadGLBModel(url, options) {
             return new Promise((resolve, reject) => {
                 gltfLoader.load(url, (gltf) => {
                     const model = gltf.scene;
                     model.userData.url = url;
                     model.userData.initialOptions = options;
                     model.userData.transform = { position: (options.position || new THREE.Vector3()).clone(), rotation: (options.rotation || new THREE.Euler()).clone(), scale: (options.scale || new THREE.Vector3(1,1,1)).clone() };
                     model.scale.copy(model.userData.transform.scale);
                     model.position.copy(model.userData.transform.position);
                     // Don't apply rotation here, apply it after loading materials in loadAllModels
                     // model.rotation.copy(model.userData.transform.rotation);
                     model.userData.isLocked = options.isLocked || false;

                     model.traverse((child) => {
                         if (child.isMesh) {
                             child.castShadow = true; child.receiveShadow = true;
                             // Use a more stable ID if available from glTF extras, otherwise fallback to UUID
                             child.userData.stableId = child.userData.stableId || child.uuid;
                             child.userData.isLocked = model.userData.isLocked;

                             const originalMaterial = Array.isArray(child.material) ? child.material.map(m => m.clone()) : child.material.clone();
                             let newMaterial, objectName = child.name;

                             const processMaterial = (mat) => {
                                 const matClone = mat.clone();
                                 matClone.userData = { ...(mat.userData || {}) }; // Preserve existing userData like stableId
                                 matClone.aoMap = null;
                                 matClone.transparent = matClone.opacity < 1;
                                 matClone.needsUpdate = true; // Crucial after cloning

                                 // זיהוי והארת הפאנלים האדומים
                                 if (url === KNESSET_MODEL_URL && mat.name && mat.name.toLowerCase().includes('mat_primitive1')) {
                                     console.log('Found potential panel material:', mat.name);
                                     matClone.emissive.setHex(0xFF0000); // צבע פליטה אדום
                                     matClone.emissiveIntensity = 1.5; // עוצמת פליטה
                                     matClone.color.setHex(0x330000); // צבע בסיס כהה יותר
                                 }
                                 return matClone;
                             };

                             if (Array.isArray(child.material)) {
                                 newMaterial = child.material.map(processMaterial);
                                 child.material = newMaterial; // Assign the array of new materials
                                 // Determine object name from materials if possible
                                 const materialNames = newMaterial.map(m => m.name).filter(Boolean);
                                 if (materialNames.length > 0) objectName = materialNames.join(' / ');

                             } else if (child.material) {
                                 newMaterial = processMaterial(child.material);
                                 child.material = newMaterial; // Assign the single new material
                                 if (newMaterial.name && newMaterial.name !== 'default') objectName = newMaterial.name;
                             } else {
                                 // Create a default material if none exists
                                 newMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd });
                                 newMaterial.userData = {};
                                 child.material = newMaterial;
                             }

                            // Determine final object name using logic function
                            if (options.nameLogic) {
                                 let specificName = options.nameLogic(objectName || child.name, newMaterial); // Pass determined name or child.name
                                 if (specificName) {
                                     objectName = specificName;
                                 } else if (!objectName || objectName.startsWith('Mesh') || objectName.startsWith('pasted_') || objectName.startsWith('Group')) {
                                     objectName = `חלק_${globalObjectCounter++}`;
                                 }
                            } else if (!objectName || objectName.startsWith('Mesh') || objectName.startsWith('pasted_') || objectName.startsWith('Group')) {
                                 objectName = `חלק_${globalObjectCounter++}`;
                            }


                             sceneObjects.push({
                                 id: child.uuid,
                                 stableId: child.userData.stableId, // Use the potentially more stable ID
                                 name: objectName,
                                 mesh: child,
                                 originalMaterial: originalMaterial, // Store the initial cloned material(s)
                                 parentModel: model
                                });
                         }
                     });
                     scene.add(model);
                     resolve(model);
                 }, (xhr) => { if (sidebarList.innerHTML.includes('טוען')) { sidebarList.innerHTML = `<div class="text-gray-400">טוען: ${url.split('/').pop()}... ${Math.round(xhr.loaded / xhr.total * 100)}%</div>`; } }, (error) => { console.error(`Error loading ${url}:`, error); reject(error); });
             });
        }
         function loadFBXModel(url, options) {
             return new Promise((resolve, reject) => {
                 fbxLoader.load(url, (object) => {
                     const model = object;
                     model.userData.url = url;
                     model.userData.initialOptions = options;
                     model.userData.transform = { position: (options.position || new THREE.Vector3()).clone(), rotation: (options.rotation || new THREE.Euler()).clone(), scale: (options.scale || new THREE.Vector3(1,1,1)).clone() };
                     model.scale.copy(model.userData.transform.scale);
                     model.position.copy(model.userData.transform.position);
                    // Don't apply rotation here
                     model.userData.isLocked = options.isLocked || false;

                     model.traverse((child) => {
                         if (child.isMesh) {
                             child.castShadow = true;
                             child.receiveShadow = true;
                             child.userData.stableId = child.uuid; // FBX doesn't usually have stable IDs in extras
                             child.userData.isLocked = model.userData.isLocked;

                             const originalMaterial = Array.isArray(child.material) ? child.material.map(m => m.clone()) : (child.material ? child.material.clone() : null);
                             let newMaterial, objectName = child.name;

                             const processMaterial = (mat) => {
                                 if (!mat) return new THREE.MeshStandardMaterial({ color: 0xdddddd, name:'default_fbx_mat' }); // Handle null material
                                 const standardMat = new THREE.MeshStandardMaterial({
                                     color: mat.color || 0xdddddd,
                                     map: mat.map || null,
                                     roughness: mat.roughness !== undefined ? mat.roughness : 0.8,
                                     metalness: mat.metalness !== undefined ? mat.metalness : 0.1,
                                     opacity: mat.opacity !== undefined ? mat.opacity : 1,
                                     transparent: (mat.opacity !== undefined && mat.opacity < 1) || mat.transparent || false,
                                     name: mat.name || 'fbx_mat' // Preserve name if exists
                                 });
                                 standardMat.userData = { ...(mat.userData || {}) };
                                 standardMat.needsUpdate = true;
                                 return standardMat;
                             };

                             if (Array.isArray(child.material)) {
                                 newMaterial = child.material.map(processMaterial);
                                 child.material = newMaterial;
                                 const materialNames = newMaterial.map(m => m.name).filter(Boolean);
                                 if (materialNames.length > 0) objectName = materialNames.join(' / ');
                             } else if (child.material) {
                                 newMaterial = processMaterial(child.material);
                                 child.material = newMaterial;
                                 if (newMaterial.name && newMaterial.name !== 'default') objectName = newMaterial.name;
                             } else {
                                 newMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd, name:'default_fbx_mat' });
                                 newMaterial.userData = {};
                                 child.material = newMaterial;
                             }

                            // Determine final object name
                            if (options.nameLogic) {
                                const specificName = options.nameLogic(objectName || child.name, newMaterial);
                                if (specificName) objectName = specificName;
                             }
                             if (!objectName || objectName.startsWith('Mesh') || objectName.startsWith('Group') || objectName.startsWith('Object_')) {
                                objectName = `חלק FBX_${globalObjectCounter++}`;
                             }


                             sceneObjects.push({
                                id: child.uuid,
                                stableId: child.userData.stableId,
                                name: objectName,
                                mesh: child,
                                originalMaterial: originalMaterial,
                                parentModel: model });
                         }
                     });
                     scene.add(model);
                     resolve(model);
                 }, (xhr) => {
                     if (sidebarList.innerHTML.includes('טוען')) { sidebarList.innerHTML = `<div class="text-gray-400">טוען: ${url.split('/').pop()}... ${Math.round(xhr.loaded / xhr.total * 100)}%</div>`; }
                 }, (error) => {
                     console.error(`Error loading ${url}:`, error);
                     reject(error);
                 });
             });
         }


        // --- UI Population ---
        // ... existing populateSidebar, populateLightList ...
         function populateSidebar() { sidebarList.innerHTML = ''; const objectsToList = sceneObjects.filter(obj => !obj.isLightHelper); if (objectsToList.length === 0) { sidebarList.innerHTML = '<div class="text-gray-400 text-sm">אין אובייקטים להצגה.</div>'; return; } objectsToList.forEach(obj => { const objElement = document.createElement('div'); objElement.id = `sidebar-item-${obj.id}`; objElement.className = 'p-3 bg-gray-700 rounded-lg shadow cursor-pointer hover:bg-gray-600 object-item'; objElement.dataset.objectId = obj.id; objElement.innerHTML = ` <h3 class="font-semibold text-lg text-white pointer-events-none">${obj.name}</h3> <p class="text-sm text-gray-400 pointer-events-none">ID: ...${obj.id.slice(-6)}</p> `; if (selectedObjects.includes(obj)) { objElement.classList.add('selected-object'); } sidebarList.appendChild(objElement); }); }
         function populateLightList() { lightListContainer.innerHTML = ''; const lightsToList = sceneObjects.filter(obj => obj.isLightHelper && obj.lightType === 'point'); if (lightsToList.length === 0) { lightListContainer.innerHTML = '<div class="text-gray-400 text-sm">אין מנורות נקודתיות להצגה.</div>'; return; } lightsToList.forEach(obj => { const lightElement = document.createElement('div'); lightElement.id = `light-item-${obj.id}`; lightElement.className = 'p-3 bg-gray-600 rounded-lg shadow cursor-pointer hover:bg-gray-500 light-item'; lightElement.dataset.objectId = obj.id; lightElement.innerHTML = ` <h3 class="font-semibold text-base text-white pointer-events-none">${obj.name.replace(' (Helper)', '')}</h3> <p class="text-xs text-gray-300 pointer-events-none">ID: ...${obj.id.slice(-6)}</p> `; if (selectedObjects.includes(obj)) { lightElement.classList.add('selected-object'); } lightListContainer.appendChild(lightElement); }); }


        // --- Panel Management ---
        // ... existing openPanel, closeSinglePanels ...
         function openPanel(panelToOpen) {
             const isOpening = panelToOpen.classList.contains('hidden');
             const isCurrentlyOpen = !isOpening;
             const isSecondaryPanel = panelToOpen === singleObjectPanel || panelToOpen === pointLightPanel;

             // Hide all OTHER main panels first
             allPanels.forEach(p => {
                 if (p !== panelToOpen && (p !== singleObjectPanel && p !== pointLightPanel)) {
                     p.classList.add('hidden');
                 }
             });
              // Close secondary panels if opening a main panel OR closing the panel we clicked
              if (!isSecondaryPanel || isCurrentlyOpen) {
                  closeSinglePanels();
              }

              // Toggle the target panel's visibility
              if (isCurrentlyOpen) {
                  panelToOpen.classList.add('hidden'); // Close if already open
              } else {
                  panelToOpen.classList.remove('hidden'); // Open if closed

                  // Reset position only when opening on desktop if it wasn't already positioned
                 const isMobile = window.innerWidth < 768;
                  const topBarHeight = document.getElementById('top-menu-bar')?.offsetHeight || 60; // Get current height
                 if (!isMobile && (!panelToOpen.style.left || !panelToOpen.style.top || panelToOpen.style.left === '50%')) { // Also reset if centered from mobile
                     // const topBarHeight = document.getElementById('top-menu-bar-wrapper')?.offsetHeight || 60; // Original - wrapper removed
                     if (isSecondaryPanel) {
                         panelToOpen.style.left = '1.25rem'; // left-5
                         panelToOpen.style.right = 'auto';
                         panelToOpen.style.transform = 'translateY(-50%)'; // Vertically center
                         panelToOpen.style.top = '50%';
                         panelToOpen.style.maxHeight = '80vh';
                     } else {
                         panelToOpen.style.right = '1.25rem'; // right-5
                         panelToOpen.style.left = 'auto';
                         panelToOpen.style.transform = ''; // Clear transform
                         panelToOpen.style.top = `${topBarHeight + 10}px`; // Position below top bar + margin
                         panelToOpen.style.maxHeight = '80vh'; // Reset max height potentially
                     }
                 } else if (isMobile) {
                      // Adjust mobile top position based on current top bar height
                      panelToOpen.style.top = `${topBarHeight + 10}px`;
                      panelToOpen.style.left = '50%'; // Center horizontally
                      panelToOpen.style.transform = 'translateX(-50%)'; // Center horizontally
                      panelToOpen.style.right = 'auto';
                      panelToOpen.style.bottom = 'auto';
                      panelToOpen.style.maxHeight = `calc(100vh - ${topBarHeight + 20}px)`; // Adjust max height
                 }
             }
        }
        function closeSinglePanels() { singleObjectPanel.classList.add('hidden'); pointLightPanel.classList.add('hidden'); }


        // --- UI Interaction Handlers ---
        // ... existing handlers ...
         function onSidebarClick(event) { const item = event.target.closest('.object-item'); if (!item) return; const objectId = item.dataset.objectId; const targetObject = sceneObjects.find(obj => obj.id === objectId); if (targetObject) { selectObject(targetObject, event); zoomToSelected(); } }
         function onLightListClick(event) { const item = event.target.closest('.light-item'); if (!item) return; const objectId = item.dataset.objectId; const targetObject = sceneObjects.find(obj => obj.id === objectId); if (targetObject) { selectObject(targetObject, event); zoomToSelected(); } }
        function onSinglePanelClick(event) {
            event.stopPropagation();
            // Allow clicks on labels to trigger inputs
             if (event.target.tagName === 'LABEL') {
                const inputId = event.target.getAttribute('for');
                const inputElement = document.getElementById(inputId);
                if (inputElement) {
                     // inputElement.click(); // Let the browser handle label clicks
                    return; // Don't process label clicks further here
                }
            }
            // Check if click is on the button itself or its child svg/path
            const button = event.target.closest('button');
            if (!button) return;

            const objectId = button.dataset.objectId;
             if (!objectId) return; // Need objectId on buttons

            const targetObject = sceneObjects.find(obj => obj.id === objectId);
            if (!targetObject) return;

            if (button.classList.contains('revert-btn')) {
                if (selectedObjects.includes(targetObject)) {
                    revertToDefault(targetObject);
                    showSingleObjectPanel(targetObject); // Refresh panel
                }
            } else if (button.classList.contains('duplicate-btn')) {
                if (!targetObject.isLightHelper && targetObject.mesh.userData.isLocked) {
                    console.warn("Cannot duplicate locked model.");
                    return;
                }
                if (targetObject.isLightHelper) {
                   if (selectedObjects.includes(targetObject)) duplicateLight(targetObject);
                } else {
                   duplicateModel(objectId);
                }
            } else if (button.classList.contains('chair-camera-btn')) {
                 if (selectedObjects.includes(targetObject)) {
                     focusCameraOnChair(targetObject);
                 }
            } else if (button.classList.contains('coalition-overlay-btn')) {
                 applyChairOverlay(targetObject, 'coalition');
                 updateOverlayButtonsState(targetObject); // Update button appearance
            } else if (button.classList.contains('opposition-overlay-btn')) {
                 applyChairOverlay(targetObject, 'opposition');
                 updateOverlayButtonsState(targetObject); // Update button appearance
            } else if (button.classList.contains('remove-overlay-btn')) {
                 applyChairOverlay(targetObject, null); // Pass null to remove
                 updateOverlayButtonsState(targetObject); // Update button appearance
            }
        }
        function onSinglePanelChange(event) {
            event.stopPropagation();
             // Ensure target has dataset.objectId, common for inputs/selects
            const objectId = event.target.dataset.objectId;
            if (!objectId) return;

            const targetObject = selectedObjects.length > 0 ? selectedObjects.find(obj => obj.id === objectId) : null;
            if (!targetObject) {
                 console.warn("No selected object found for change event, ID:", objectId);
                 return;
             }

            // Texture/Bump Upload
            if (event.target.classList.contains('texture-upload-input')) {
                // ... (existing texture upload logic) ...
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (e) => await applyTextureFromDataUrl(targetObject, e.target.result);
                reader.readAsDataURL(file);
                event.target.value = null;
                return;
            }
            if (event.target.classList.contains('bump-upload-input')) {
                // ... (existing bump upload logic) ...
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (e) => await applyBumpMapFromDataUrl(targetObject, e.target.result);
                reader.readAsDataURL(file);
                event.target.value = null;
                return;
            }

            // Chair Upholstery Color Change
            if (event.target.classList.contains('chair-color-picker')) {
                 const newColor = event.target.value;
                 applyChairUpholsteryColor(targetObject, newColor, event.type === 'change'); // Add history on 'change'
                 return; // Handled chair color specifically
            }


            // General Material Property Change (for non-chair objects or non-upholstery parts)
            const materialToChange = getMaterialToChange(targetObject.mesh);
            if (!materialToChange) return;

            let propertyName = null, newValue = null, beforeValue = null;
            const firstMat = Array.isArray(materialToChange) ? materialToChange[0] : materialToChange;
             // Ensure firstMat exists before accessing properties
             if (!firstMat) return;

            if (event.target.classList.contains('color-picker')) {
                propertyName = 'color';
                newValue = event.target.value;
                beforeValue = '#' + firstMat.color.getHexString();
            } else if (event.target.classList.contains('roughness-slider')) {
                propertyName = 'roughness';
                newValue = parseFloat(event.target.value);
                beforeValue = firstMat.roughness;
            } else if (event.target.classList.contains('metalness-slider')) {
                propertyName = 'metalness';
                newValue = parseFloat(event.target.value);
                beforeValue = firstMat.metalness;
            } else if (event.target.classList.contains('opacity-slider')) {
                propertyName = 'opacity';
                newValue = parseFloat(event.target.value);
                beforeValue = firstMat.opacity;
            } else if (event.target.classList.contains('emissive-intensity-slider')) {
                propertyName = 'emissiveIntensity';
                newValue = parseFloat(event.target.value);
                beforeValue = firstMat.emissiveIntensity;
            }

            // Add history only on final change (e.g., mouseup on slider, 'change' event for color picker)
             if (propertyName && newValue !== beforeValue && event.type === 'change') {
                 // Check if it's the chair upholstery being colored directly (not via overlay logic)
                 if (!(targetObject.name === 'ריפוד כיסא' && propertyName === 'color')) {
                     addHistory({ type: 'material', mesh: targetObject.mesh, property: propertyName, before: beforeValue, after: newValue });
                 }
             }


            // Apply change to material(s) - Excluding chair upholstery color handled separately
             if (!(targetObject.name === 'ריפוד כיסא' && propertyName === 'color')) {
                 const applyToMaterial = (mat) => {
                     if (event.target.classList.contains('color-picker')) {
                         mat.color.set(event.target.value);
                         mat.map = null; // Remove texture if color is set
                         mat.userData.textureDataUrl = null;
                     }
                     if (event.target.classList.contains('roughness-slider')) mat.roughness = parseFloat(event.target.value);
                     if (event.target.classList.contains('metalness-slider')) mat.metalness = parseFloat(event.target.value);
                     if (event.target.classList.contains('opacity-slider')) {
                         mat.opacity = parseFloat(event.target.value);
                         mat.transparent = mat.opacity < 1;
                     }
                      if (event.target.classList.contains('emissive-intensity-slider')) {
                         mat.emissiveIntensity = parseFloat(event.target.value);
                     }
                     mat.needsUpdate = true;
                 };

                 if (Array.isArray(materialToChange)) materialToChange.forEach(applyToMaterial);
                 else applyToMaterial(materialToChange);
             }
        }
        function onPointLightPanelClick(event) { event.stopPropagation(); if (event.target.classList.contains('duplicate-btn')) { const lastSelected = selectedObjects.length > 0 ? selectedObjects[selectedObjects.length - 1] : null; if (lastSelected && lastSelected.isLightHelper) { duplicateLight(lastSelected); } } }
        function onPointLightPanelChange(event) { const lastSelected = selectedObjects.length > 0 ? selectedObjects[selectedObjects.length - 1] : null; if (!lastSelected || !lastSelected.isLightHelper || lastSelected.lightType !== 'point') return; const light = lightHelpersMap.get(lastSelected.mesh); if (!light) return; const target = event.target; let property, value, beforeValue; let isShadowProperty = false; if (target.id === 'pl-intensity-slider') { property = 'intensity'; value = parseFloat(target.value); beforeValue = light.intensity; plIntensityValueSpan.textContent = value.toFixed(1); } else if (target.id === 'pl-distance-slider') { property = 'distance'; value = parseFloat(target.value); beforeValue = light.distance; plDistanceValueSpan.textContent = value.toFixed(1); } else if (target.id === 'pl-color-picker') { property = 'color'; value = target.value; beforeValue = '#' + light.color.getHexString(); } else if (target.id === 'pl-cast-shadow-checkbox') { property = 'castShadow'; value = target.checked; beforeValue = light.castShadow; isShadowProperty = true; } else if (target.id === 'pl-shadow-bias-slider') { property = 'bias'; value = parseFloat(target.value); beforeValue = light.shadow.bias; isShadowProperty = true; } else if (target.id === 'pl-shadow-normal-bias-slider') { property = 'normalBias'; value = parseFloat(target.value); beforeValue = light.shadow.normalBias; isShadowProperty = true; } if (property !== undefined && value !== beforeValue) { const isFinalChange = event.type === 'change'; if (property === 'castShadow' && value === true) { const currentShadowCasters = pointLights.filter(pl => pl.light.castShadow).length; const countExcludingCurrent = pointLights.filter(pl => pl.light.castShadow && pl.light !== light).length; if (countExcludingCurrent >= MAX_SHADOW_CASTING_POINT_LIGHTS) { console.warn(`מגבלת מנורות מטילות צל (${MAX_SHADOW_CASTING_POINT_LIGHTS}) הושגה. לא ניתן להפעיל צל למנורה זו.`); target.checked = false; plCastShadowCheckbox.disabled = true; setTimeout(() => plCastShadowCheckbox.disabled = false, 100); return; } } if (isFinalChange) { addHistory({ type: 'lightProperty', light: light, property: property, isShadowProperty: isShadowProperty, before: beforeValue, after: value }); } if (property === 'color') { light.color.set(value); const helper = lastSelected.mesh; if (helper && helper.material) helper.material.color.set(value); } else if (isShadowProperty) { if (light.shadow.map) { light.shadow.map.dispose(); light.shadow.map = null; } light.shadow[property] = value; if(property === 'castShadow') light.castShadow = value; } else { light[property] = value; } if (property === 'distance') updateRangeIndicator(); } }
        function onDoubleClick(event) { event.stopPropagation(); const rect = renderer.domElement.getBoundingClientRect(); mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(mouse, camera); const intersectableObjects = sceneObjects.map(obj => obj.mesh); const intersects = raycaster.intersectObjects(intersectableObjects, false); if (intersects.length > 0) { let intersectedSceneObject = null; for (const intersect of intersects) { intersectedSceneObject = sceneObjects.find(obj => obj.mesh === intersect.object); if (intersectedSceneObject) break; } if (intersectedSceneObject) { deselectObject(); selectObject(intersectedSceneObject, event); } } else { deselectObject(); closeSinglePanels(); } }


        // --- Selection and UI Update ---
        // ... existing functions ...
         function showSingleObjectPanelBasedOnSelection() { closeSinglePanels(); if (selectedObjects.length === 1) { const lastSelected = selectedObjects[0]; if (lastSelected) { showSingleObjectPanel(lastSelected); } } }
         function showSingleObjectPanel(obj) {
            closeSinglePanels();
            const titleEl = document.getElementById('single-object-title-static');
            titleEl.textContent = obj.name;

            if (obj.isLightHelper) {
                // Handle light helper panel display (unchanged)
                 if (obj.lightType === 'point') {
                    const light = lightHelpersMap.get(obj.mesh);
                    if (light) {
                        const plTitle = document.getElementById('point-light-title');
                        plTitle.textContent = obj.name.replace(' (Helper)', '');
                        plIntensitySlider.value = light.intensity;
                        plDistanceSlider.value = light.distance;
                        plIntensityValueSpan.textContent = light.intensity.toFixed(1);
                        plDistanceValueSpan.textContent = light.distance.toFixed(1);
                        plColorPicker.value = '#' + light.color.getHexString();
                        plCastShadowCheckbox.checked = light.castShadow;
                        plShadowBiasSlider.value = light.shadow.bias;
                        plShadowNormalBiasSlider.value = light.shadow.normalBias;
                        const currentShadowCasters = pointLights.filter(pl => pl.light.castShadow).length;
                        const canEnableShadow = light.castShadow || currentShadowCasters < MAX_SHADOW_CASTING_POINT_LIGHTS;
                        plCastShadowCheckbox.disabled = !canEnableShadow;
                        pointLightPanel.querySelector('.duplicate-btn').dataset.objectId = obj.id;
                        openPanel(pointLightPanel);
                    }
                }
            } else {
                // Handle regular object panel display
                const controlsContainer = document.getElementById('single-object-controls');
                const isChairModelPart = obj.parentModel && obj.parentModel.userData.url === CHAIR_MODEL_URL;
                const isChairUpholstery = isChairModelPart && obj.name === 'ריפוד כיסא'; // Use the specific name
                const isKnessetPanel = obj.parentModel && obj.parentModel.userData.url === KNESSET_MODEL_URL && obj.name === 'פאנל LED';

                let currentMaterial = getMaterialToChange(obj.mesh);
                let firstMat = Array.isArray(currentMaterial) ? currentMaterial[0] : currentMaterial;
                firstMat = firstMat || new THREE.MeshStandardMaterial(); // Fallback if no material

                // Get base color, possibly from stored properties if overlay is active
                let startColor = firstMat.color.getHexString();
                if (isChairUpholstery && firstMat.userData.originalSeatMaterialProperties?.color) {
                     startColor = firstMat.userData.originalSeatMaterialProperties.color.replace('#','');
                }

                const startRoughness = firstMat.roughness !== undefined ? firstMat.roughness : 1;
                const startMetalness = firstMat.metalness !== undefined ? firstMat.metalness : 0;
                const startOpacity = firstMat.opacity !== undefined ? firstMat.opacity : 1;
                const startEmissiveIntensity = firstMat.emissiveIntensity !== undefined ? firstMat.emissiveIntensity : 0;
                const hasBump = firstMat.bumpMap;

                let materialControlsHtml = '';
                let chairSpecificControlsHtml = '';

                // Add chair-specific controls
                if (isChairUpholstery) {
                    chairSpecificControlsHtml = `
                        <hr class="border-gray-600">
                        <h4 class="font-semibold text-gray-200">בקרת ריפוד כיסא</h4>
                        <div>
                            <label for="chair-color-${obj.id}" class="text-sm text-gray-300">צבע ריפוד בסיס</label>
                            <input type="color" class="chair-color-picker w-full h-10 p-1 bg-gray-700 border border-gray-600 rounded cursor-pointer" id="chair-color-${obj.id}" data-object-id="${obj.id}" value="#${startColor}">
                        </div>
                        <div class="mt-2">
                             <label class="text-sm text-gray-300 mb-1 block">סימון מושב</label>
                             <div class="flex space-x-2 space-x-reverse">
                                <button class="overlay-btn coalition-overlay-btn flex-1 px-3 py-1 text-sm bg-green-600 hover:bg-green-700 rounded text-white transition-colors" data-object-id="${obj.id}">קואליציה</button>
                                <button class="overlay-btn opposition-overlay-btn flex-1 px-3 py-1 text-sm bg-orange-600 hover:bg-orange-700 rounded text-white transition-colors" data-object-id="${obj.id}">אופוזיציה</button>
                             </div>
                             <button class="remove-overlay-btn w-full mt-2 px-3 py-1 text-sm bg-gray-600 hover:bg-gray-700 rounded text-white transition-colors" data-object-id="${obj.id}">הסר סימון</button>
                        </div>
                        <hr class="border-gray-600">
                         <div><label for="upload-single-${obj.id}" class="text-sm text-gray-300">טקסטורת ריפוד</label><input type="file" class="texture-upload-input" id="upload-single-${obj.id}" data-object-id="${obj.id}" accept="image/*"></div>
                         <div><label for="bump-upload-${obj.id}" class="text-sm text-gray-300">טקסטורת בליטות ריפוד ${hasBump ? '<span class="text-green-400">(טעון)</span>' : ''}</label><input type="file" class="bump-upload-input" id="bump-upload-${obj.id}" data-object-id="${obj.id}" accept="image/*"></div>

                    `;
                     // Don't show general material controls for upholstery, only specific ones
                } else if (isChairModelPart) {
                    // Show general controls for other chair parts (base, wheels)
                    materialControlsHtml = `
                        <hr class="border-gray-600">
                        <h4 class="font-semibold text-gray-200">בקרת חומר (${obj.name})</h4>
                        <button class="revert-btn w-full px-3 py-1 text-sm bg-yellow-600 hover:bg-yellow-700 rounded text-white transition-colors" data-object-id="${obj.id}">שחזר חומר לברירת מחדל</button>
                        <div><label for="color-${obj.id}" class="text-sm text-gray-300">צבע בסיס</label><input type="color" class="material-control color-picker w-full h-10 p-1 bg-gray-700 border border-gray-600 rounded cursor-pointer" id="color-${obj.id}" data-object-id="${obj.id}" value="#${startColor}"></div>
                        <div><label for="roughness-${obj.id}" class="text-sm text-gray-300">חספוס</label><input type="range" class="material-control roughness-slider w-full" id="roughness-${obj.id}" data-object-id="${obj.id}" min="0" max="1" step="0.01" value="${startRoughness}"></div>
                        <div><label for="metalness-${obj.id}" class="text-sm text-gray-300">מתכתיות</label><input type="range" class="material-control metalness-slider w-full" id="metalness-${obj.id}" data-object-id="${obj.id}" min="0" max="1" step="0.01" value="${startMetalness}"></div>
                        <hr class="border-gray-600">
                        <div><label for="upload-single-${obj.id}" class="text-sm text-gray-300">טקסטורת צבע</label><input type="file" class="texture-upload-input" id="upload-single-${obj.id}" data-object-id="${obj.id}" accept="image/*"></div>
                        <div><label for="bump-upload-${obj.id}" class="text-sm text-gray-300">טקסטורת בליטות ${hasBump ? '<span class="text-green-400">(טעון)</span>' : ''}</label><input type="file" class="bump-upload-input" id="bump-upload-${obj.id}" data-object-id="${obj.id}" accept="image/*"></div>
                    `;
                 } else {
                     // Show general material controls for non-chair objects
                    materialControlsHtml = `
                        <button class="revert-btn w-full px-3 py-1 text-sm bg-yellow-600 hover:bg-yellow-700 rounded text-white transition-colors" data-object-id="${obj.id}">שחזר חומר לברירת מחדל</button>
                        <hr class="border-gray-600">
                        <h4 class="font-semibold text-gray-200">בקרת חומרים</h4>
                        <div><label for="color-${obj.id}" class="text-sm text-gray-300">צבע בסיס</label><input type="color" class="material-control color-picker w-full h-10 p-1 bg-gray-700 border border-gray-600 rounded cursor-pointer" id="color-${obj.id}" data-object-id="${obj.id}" value="#${startColor}"></div>
                        <div><label for="roughness-${obj.id}" class="text-sm text-gray-300">חספוס</label><input type="range" class="material-control roughness-slider w-full" id="roughness-${obj.id}" data-object-id="${obj.id}" min="0" max="1" step="0.01" value="${startRoughness}"></div>
                        <div><label for="metalness-${obj.id}" class="text-sm text-gray-300">מתכתיות</label><input type="range" class="material-control metalness-slider w-full" id="metalness-${obj.id}" data-object-id="${obj.id}" min="0" max="1" step="0.01" value="${startMetalness}"></div>
                        <div><label for="opacity-${obj.id}" class="text-sm text-gray-300">שקיפות</label><input type="range" class="material-control opacity-slider w-full" id="opacity-${obj.id}" data-object-id="${obj.id}" min="0" max="1" step="0.01" value="${startOpacity}"></div>
                        ${isKnessetPanel ? `<div><label for="emissive-${obj.id}" class="text-sm text-gray-300">עוצמת פליטה</label><input type="range" class="material-control emissive-intensity-slider w-full" id="emissive-${obj.id}" data-object-id="${obj.id}" min="0" max="5" step="0.1" value="${startEmissiveIntensity}"></div>` : ''}
                        <hr class="border-gray-600">
                        <div><label for="upload-single-${obj.id}" class="text-sm text-gray-300">טקסטורת צבע</label><input type="file" class="texture-upload-input" id="upload-single-${obj.id}" data-object-id="${obj.id}" accept="image/*"></div>
                        <div><label for="bump-upload-${obj.id}" class="text-sm text-gray-300">טקסטורת בליטות ${hasBump ? '<span class="text-green-400">(טעון)</span>' : ''}</label><input type="file" class="bump-upload-input" id="bump-upload-${obj.id}" data-object-id="${obj.id}" accept="image/*"></div>
                    `;
                }

                 // Shared controls for all non-light objects
                const sharedControlsHtml = `
                     <button class="duplicate-btn w-full px-3 py-1 text-sm bg-blue-600 hover:bg-blue-700 rounded text-white transition-colors" data-object-id="${obj.id}" ${obj.mesh.userData.isLocked ? 'disabled' : ''}>שכפל מודל</button>
                     ${isChairModelPart ? `<button class="chair-camera-btn w-full mt-2 px-3 py-1 text-sm bg-purple-600 hover:bg-purple-700 rounded text-white transition-colors" data-object-id="${obj.id}">מבט מצלמה</button>` : ''}
                 `;

                controlsContainer.innerHTML = `
                    <div class="space-y-4">
                        ${sharedControlsHtml}
                        ${chairSpecificControlsHtml}
                        ${materialControlsHtml}
                    </div>`;

                 // Update overlay button active state for chairs
                 if (isChairUpholstery) {
                     updateOverlayButtonsState(obj);
                 }

                openPanel(singleObjectPanel);
            }
        }
         function selectObject(sceneObjectData, event) {
             const isCtrlClick = event.ctrlKey || event.metaKey;
             const isSelected = selectedObjects.includes(sceneObjectData);

             if (isCtrlClick) {
                 if (isSelected) { selectedObjects = selectedObjects.filter(obj => obj !== sceneObjectData); }
                 else { selectedObjects.push(sceneObjectData); }
             } else {
                 if (!(selectedObjects.length === 1 && isSelected)) {
                     deselectObject();
                     selectedObjects = [sceneObjectData];
                 }
             }

            updateSelectionHighlight();

            if (selectedObjects.length > 0) {
                 const lastSelected = selectedObjects[selectedObjects.length - 1];
                 const objectToAttachTo = lastSelected.parentModel || lastSelected.mesh;
                 const isLocked = lastSelected.mesh.userData.isLocked;

                if (objectToAttachTo && !isLocked) {
                     transformControls.attach(objectToAttachTo);
                 } else {
                     transformControls.detach();
                 }

                if (lastSelected.isLightHelper && lastSelected.lightType === 'point') { createOrUpdateRangeIndicator(); }
                else { removeRangeIndicator(); }
                 showSingleObjectPanelBasedOnSelection();
            } else {
                 deselectObject();
            }
        }
        function deselectObject() {
            removeRangeIndicator();
            selectedObjects = [];
            // Check if transformControls is initialized before calling detach
            if (transformControls) {
                transformControls.detach();
            }
            updateSelectionHighlight();
            closeSinglePanels();
        }
        function updateSelectionHighlight() { document.querySelectorAll('#object-list .object-item').forEach(item => { const objectId = item.dataset.objectId; const sceneObj = sceneObjects.find(obj => obj.id === objectId); item.classList.toggle('selected-object', sceneObj && selectedObjects.includes(sceneObj)); }); document.querySelectorAll('#light-list .light-item').forEach(item => { const objectId = item.dataset.objectId; const sceneObj = sceneObjects.find(obj => obj.id === objectId); item.classList.toggle('selected-object', sceneObj && selectedObjects.includes(sceneObj)); }); }


        // --- Chair Specific Functions ---
        // ... existing functions ...
         function getChairUpholsteryObject(chairParentModel) {
            if (!chairParentModel || chairParentModel.userData.url !== CHAIR_MODEL_URL) return null;
            return sceneObjects.find(obj => obj.parentModel === chairParentModel && obj.name === 'ריפוד כיסא');
        }

        function applyChairUpholsteryColor(upholsteryObjectData, newColorHex, addToHistory = true) {
             if (!upholsteryObjectData || upholsteryObjectData.name !== 'ריפוד כיסא') return;

             const material = getMaterialToChange(upholsteryObjectData.mesh);
             if (!material) return;
             const mat = Array.isArray(material) ? material[0] : material; // Assume single material for upholstery

            const beforeColor = '#' + mat.color.getHexString();
            const beforeOverlayState = upholsteryObjectData.parentModel.userData.overlayState;

            // Store the new base color even if overlay is active
            if (!mat.userData.originalSeatMaterialProperties) {
                mat.userData.originalSeatMaterialProperties = {}; // Initialize if needed
            }
            mat.userData.originalSeatMaterialProperties.color = newColorHex; // Store the intended base color

            if (addToHistory && beforeColor !== newColorHex) {
                 addHistory({ type: 'chairColor', objectData: upholsteryObjectData, before: {color: beforeColor, overlay: beforeOverlayState}, after: {color: newColorHex, overlay: beforeOverlayState} });
            }

            // Apply color only if no overlay is active
            if (!upholsteryObjectData.parentModel.userData.overlayState) {
                mat.color.set(newColorHex);
                mat.map = null; // Remove texture when applying solid color
                mat.userData.textureDataUrl = null;
                mat.needsUpdate = true;
            }
        }

        function getOverlayMaterial(type) {
             const color = type === 'coalition' ? 0x00FF00 : 0xFFA500; // Corrected Orange hex
             const cacheKey = type;

             if (!overlayMaterials[cacheKey]) {
                overlayMaterials[cacheKey] = new THREE.MeshStandardMaterial({
                     color: color,
                     transparent: true,
                     opacity: 0.6, // Semi-transparent
                     roughness: 0.8, // Match default roughness maybe
                     metalness: 0.1
                });
                overlayMaterials[cacheKey].userData = { isOverlay: true, overlayType: type }; // Mark as overlay
            }
            return overlayMaterials[cacheKey];
        }

        function applyChairOverlay(upholsteryObjectData, overlayType, addToHistory = true) { // overlayType can be 'coalition', 'opposition', or null
            if (!upholsteryObjectData || upholsteryObjectData.name !== 'ריפוד כיסא') return;

            const material = getMaterialToChange(upholsteryObjectData.mesh);
            if (!material) return;
            const mat = Array.isArray(material) ? material[0] : material;

            const currentOverlay = upholsteryObjectData.parentModel.userData.overlayState;
             if (currentOverlay === overlayType) return; // No change needed

             const beforeState = {
                 overlay: currentOverlay,
                 // Capture material props before potentially changing them
                 color: '#' + mat.color.getHexString(),
                 roughness: mat.roughness,
                 metalness: mat.metalness,
                 opacity: mat.opacity,
                 map: mat.userData.textureDataUrl,
                 bumpMap: mat.userData.bumpDataUrl
             };


             if (overlayType) { // Applying coalition or opposition
                // Store current base material properties if not already stored (or if switching overlays)
                if (!mat.userData.isOverlay || !mat.userData.originalSeatMaterialProperties) {
                    mat.userData.originalSeatMaterialProperties = {
                        color: '#' + mat.color.getHexString(),
                        roughness: mat.roughness,
                        metalness: mat.metalness,
                        opacity: mat.opacity,
                        textureDataUrl: mat.userData.textureDataUrl || null,
                        bumpDataUrl: mat.userData.bumpDataUrl || null,
                    };
                }

                const overlayMat = getOverlayMaterial(overlayType);
                upholsteryObjectData.mesh.material = overlayMat; // Assign overlay material
                upholsteryObjectData.parentModel.userData.overlayState = overlayType;

            } else { // Removing overlay
                if (mat.userData.originalSeatMaterialProperties) {
                     // Restore base material from stored properties
                     const props = mat.userData.originalSeatMaterialProperties;
                     const restoredMaterial = new THREE.MeshStandardMaterial({
                         color: props.color || '#ffffff',
                         roughness: props.roughness !== undefined ? props.roughness : 0.8,
                         metalness: props.metalness !== undefined ? props.metalness : 0.1,
                         opacity: props.opacity !== undefined ? props.opacity : 1,
                         transparent: (props.opacity !== undefined && props.opacity < 1)
                     });
                     restoredMaterial.userData = { originalSeatMaterialProperties: { ...props } }; // Keep stored props

                     upholsteryObjectData.mesh.material = restoredMaterial;

                     // Re-apply textures if they existed
                     if (props.textureDataUrl) {
                        applyTextureFromDataUrl(upholsteryObjectData, props.textureDataUrl, false); // false = don't add history again
                     }
                      if (props.bumpDataUrl) {
                        applyBumpMapFromDataUrl(upholsteryObjectData, props.bumpDataUrl, false);
                     }

                 } else {
                     // If no stored properties, revert to the object's original loaded material
                     revertToDefault(upholsteryObjectData, false); // Revert without adding history again
                 }
                // Clear stored properties only after restoring
                // delete mat.userData.originalSeatMaterialProperties; // Keep it so changing base color still works
                upholsteryObjectData.parentModel.userData.overlayState = null;
            }

            if (addToHistory) {
                const finalMat = getMaterialToChange(upholsteryObjectData.mesh);
                const afterMat = Array.isArray(finalMat) ? finalMat[0] : finalMat;
                 if (!afterMat) return; // Exit if material is somehow gone
                const afterState = {
                     overlay: overlayType,
                     color: '#' + afterMat.color.getHexString(),
                     roughness: afterMat.roughness,
                     metalness: afterMat.metalness,
                     opacity: afterMat.opacity,
                     map: afterMat.userData.textureDataUrl,
                     bumpMap: afterMat.userData.bumpDataUrl
                };
                 addHistory({ type: 'chairOverlay', objectData: upholsteryObjectData, before: beforeState, after: afterState });
            }

             // Refresh panel if this object is selected
            if (selectedObjects.includes(upholsteryObjectData)) {
                showSingleObjectPanel(upholsteryObjectData);
            }
        }

        function updateOverlayButtonsState(upholsteryObjectData) {
            const panel = document.getElementById('single-object-panel');
            if (!panel || panel.classList.contains('hidden')) return;

            const coalitionBtn = panel.querySelector('.coalition-overlay-btn');
            const oppositionBtn = panel.querySelector('.opposition-overlay-btn');
            const removeBtn = panel.querySelector('.remove-overlay-btn');

            if (!coalitionBtn || !oppositionBtn || !removeBtn) return; // Buttons not found (not a chair upholstery panel)

            const currentState = upholsteryObjectData?.parentModel?.userData?.overlayState;

            coalitionBtn.classList.toggle('active', currentState === 'coalition');
            oppositionBtn.classList.toggle('active', currentState === 'opposition');
            removeBtn.disabled = !currentState; // Disable remove if no overlay
        }


        // --- Range Indicator ---
        // ... existing functions ...
         function createOrUpdateRangeIndicator() { if (selectedObjects.length === 0) return; const lastSelected = selectedObjects[selectedObjects.length - 1]; if (!lastSelected || !lastSelected.isLightHelper || lastSelected.lightType !== 'point') { removeRangeIndicator(); return; } const light = lightHelpersMap.get(lastSelected.mesh); if (!light) return; if (!lightRangeIndicator) { const geometry = new THREE.SphereGeometry(1, 32, 16); const material = new THREE.MeshBasicMaterial({ color: 0xFF8C00, wireframe: true, transparent: true, opacity: 0.3 }); lightRangeIndicator = new THREE.Mesh(geometry, material); scene.add(lightRangeIndicator); } lightRangeIndicator.position.copy(lastSelected.mesh.position); lightRangeIndicator.scale.setScalar(light.distance); lightRangeIndicator.visible = true; }
         function updateRangeIndicator() { if (selectedObjects.length === 0) return; const lastSelected = selectedObjects[selectedObjects.length - 1]; if (lightRangeIndicator && lastSelected && lastSelected.isLightHelper && lastSelected.lightType === 'point') { const light = lightHelpersMap.get(lastSelected.mesh); if (light) { lightRangeIndicator.position.copy(lastSelected.mesh.position); lightRangeIndicator.scale.setScalar(light.distance); } } }
         function removeRangeIndicator() { if (lightRangeIndicator) lightRangeIndicator.visible = false; }


        // --- Utility Functions ---
        // ... existing functions ...
         function setGizmoMode(mode) { transformControls.setMode(mode); gizmoButtons.forEach(btn => btn.classList.remove('active')); if (mode === 'translate') translateBtn.classList.add('active'); if (mode === 'rotate') rotateBtn.classList.add('active'); if (mode === 'scale') scaleBtn.classList.add('active'); }
         function toggleLightHelpers() {
            areLightHelpersVisible = !areLightHelpersVisible;

            pointLights.forEach(pl => {
                if (pl.helper) {
                    pl.helper.visible = areLightHelpersVisible;
                }
            });

            toggleLightHelpersBtn.classList.toggle('active', areLightHelpersVisible);
        }
         // --- Updated makeDraggable Function ---
         function makeDraggable(panel) {
             const handle = panel.querySelector('.draggable-handle');
             if (!handle) return;

             // Only enable dragging on non-mobile devices
             if (window.innerWidth < 768) {
                 // Remove potential leftover listeners if window was resized from desktop to mobile
                 handle.onmousedown = null; // Clear previous listener if any
                 return;
             }

             let isDragging = false;
             let startX, startY, initialLeft, initialTop;

             handle.onmousedown = (e) => {
                 // Prevent dragging if clicking on interactive elements within the handle
                 if (e.target.closest('button, input, label, select')) return;

                 e.preventDefault(); // Prevent text selection
                 isDragging = true;
                 handle.style.cursor = 'grabbing'; // Change cursor

                 // Record starting mouse position and panel position
                 startX = e.clientX;
                 startY = e.clientY;
                 const panelRect = panel.getBoundingClientRect();
                 initialLeft = panelRect.left;
                 initialTop = panelRect.top;

                 // Switch to explicit left/top positioning for smooth dragging
                 panel.style.right = 'auto';
                 panel.style.bottom = 'auto';
                 panel.style.transform = ''; // Clear any transforms like translate(-50%, -50%)
                 panel.style.left = `${initialLeft}px`;
                 panel.style.top = `${initialTop}px`;

                 document.addEventListener('mousemove', onMouseMove);
                 document.addEventListener('mouseup', onMouseUp, { once: true }); // Use { once: true } for automatic cleanup
             };

             function onMouseMove(e) {
                 if (!isDragging) return;

                 const dx = e.clientX - startX;
                 const dy = e.clientY - startY;

                 let newX = initialLeft + dx;
                 let newY = initialTop + dy;

                 // Clamp position within viewport
                 const panelRect = panel.getBoundingClientRect(); // Get current dimensions
                 const topMenuBar = document.getElementById('top-menu-bar');
                 const menuBarHeight = topMenuBar ? topMenuBar.offsetHeight : 0;
                 const topLimit = menuBarHeight + 5; // Add a small buffer

                 newX = Math.max(0, Math.min(newX, window.innerWidth - panelRect.width));
                 newY = Math.max(topLimit, Math.min(newY, window.innerHeight - panelRect.height));

                 // Update panel position directly
                 panel.style.left = `${newX}px`;
                 panel.style.top = `${newY}px`;
             }

             function onMouseUp() {
                 if (isDragging) {
                     isDragging = false;
                     handle.style.cursor = 'move'; // Restore cursor
                     document.removeEventListener('mousemove', onMouseMove);
                     // mouseup listener is automatically removed due to { once: true }
                 }
             }

             // Ensure the handle has the correct cursor initially
             handle.style.cursor = 'move';
         }
         function getMaterialToChange(mesh) {
            if (!mesh) return null;
            let material = mesh.material;
            if (!material) { console.warn("getMaterialToChange: No material found on mesh.", mesh); return null; }
            // Ensure userData exists for storing properties
            if (Array.isArray(material)) {
                material.forEach(mat => { if (!mat) return; if (!mat.userData) mat.userData = {}; }); // Check if mat exists
            } else {
                 if (!material.userData) material.userData = {};
            }
            return material;
         }


        // --- Material & Texture Application (Async) ---
        // ... existing functions ...
          async function applyTextureFromDataUrl(sceneObject, dataUrl, addToHistory = true) {
             const mesh = sceneObject.mesh;
             if (!mesh) return;
             const materialToChange = getMaterialToChange(mesh);
             if (!materialToChange) return;

             const isChairUpholstery = sceneObject.name === 'ריפוד כיסא';
             const firstMat = Array.isArray(materialToChange) ? materialToChange[0] : materialToChange;
             if (!firstMat) return; // Exit if no material

            if (addToHistory) {
                 const beforeValue = firstMat.userData.textureDataUrl || null;
                 if (beforeValue !== dataUrl) {
                     // If it's chair upholstery, use specific history type
                     if (isChairUpholstery) {
                         const beforeOverlay = sceneObject.parentModel?.userData?.overlayState; // Safe access
                         addHistory({ type: 'chairTexture', objectData: sceneObject, before: { map: beforeValue, overlay: beforeOverlay }, after: { map: dataUrl, overlay: beforeOverlay } });
                     } else {
                         addHistory({ type: 'material', mesh: mesh, property: 'map', before: beforeValue, after: dataUrl });
                     }
                 }
             }

            return new Promise((resolve, reject) => {
                 textureLoader.load(dataUrl, (texture) => {
                     texture.wrapS = THREE.RepeatWrapping;
                     texture.wrapT = THREE.RepeatWrapping;
                    // texture.repeat.set(4, 4); // Keep repeat or adjust as needed
                     texture.colorSpace = THREE.SRGBColorSpace;
                     texture.needsUpdate = true; // Ensure texture updates

                    const dataUrlToSave = dataUrl;
                    const applyToMaterial = (mat) => {
                         if (!mat) return; // Skip if material is null/undefined
                         mat.map = texture.clone(); // Use clone for safety
                         mat.color.set(0xffffff); // Standard practice when using a texture map
                         mat.userData.textureDataUrl = dataUrlToSave;
                         // Store texture in originalSeatMaterialProperties if it's upholstery
                         if (isChairUpholstery) {
                             if (!mat.userData.originalSeatMaterialProperties) mat.userData.originalSeatMaterialProperties = {};
                             mat.userData.originalSeatMaterialProperties.textureDataUrl = dataUrlToSave;
                             mat.userData.originalSeatMaterialProperties.color = '#ffffff'; // Base color becomes white with texture
                         }
                         mat.needsUpdate = true;
                     };

                    if (Array.isArray(materialToChange)) materialToChange.forEach(applyToMaterial);
                    else applyToMaterial(materialToChange);

                    // Re-apply overlay if it was active on chair upholstery
                    if (isChairUpholstery && sceneObject.parentModel?.userData?.overlayState) { // Safe access
                         applyChairOverlay(sceneObject, sceneObject.parentModel.userData.overlayState, false); // Reapply without history
                    }


                     resolve();
                 }, undefined, (err) => { console.error('Error loading texture from Data URL:', err); reject(err); });
             });
         }
        async function applyBumpMapFromDataUrl(sceneObject, dataUrl, addToHistory = true) {
            const mesh = sceneObject.mesh;
             if (!mesh) return;
             const materialToChange = getMaterialToChange(mesh);
             if (!materialToChange) return;

             const isChairUpholstery = sceneObject.name === 'ריפוד כיסא';
             const firstMat = Array.isArray(materialToChange) ? materialToChange[0] : materialToChange;
             if (!firstMat) return; // Exit if no material


             if (addToHistory) {
                 const beforeValue = firstMat.userData.bumpDataUrl || null;
                 if (beforeValue !== dataUrl) {
                     // If it's chair upholstery, use specific history type
                     if (isChairUpholstery) {
                         const beforeOverlay = sceneObject.parentModel?.userData?.overlayState; // Safe access
                          addHistory({ type: 'chairBump', objectData: sceneObject, before: { bumpMap: beforeValue, overlay: beforeOverlay }, after: { bumpMap: dataUrl, overlay: beforeOverlay } });
                     } else {
                         addHistory({ type: 'material', mesh: mesh, property: 'bumpMap', before: beforeValue, after: dataUrl });
                     }
                 }
             }

            return new Promise((resolve, reject) => {
                 textureLoader.load(dataUrl, (texture) => {
                     texture.wrapS = THREE.RepeatWrapping;
                     texture.wrapT = THREE.RepeatWrapping;
                     texture.needsUpdate = true;

                    const dataUrlToSave = dataUrl;
                    const applyToMaterial = (mat) => {
                         if (!mat) return; // Skip null materials
                         mat.bumpMap = texture.clone();
                         mat.bumpScale = 0.05; // Or keep existing/saved scale
                         mat.userData.bumpDataUrl = dataUrlToSave;
                         // Store bump in originalSeatMaterialProperties if it's upholstery
                          if (isChairUpholstery) {
                             if (!mat.userData.originalSeatMaterialProperties) mat.userData.originalSeatMaterialProperties = {};
                             mat.userData.originalSeatMaterialProperties.bumpDataUrl = dataUrlToSave;
                         }
                         mat.needsUpdate = true;
                     };

                    if (Array.isArray(materialToChange)) materialToChange.forEach(applyToMaterial);
                    else applyToMaterial(materialToChange);

                     // Re-apply overlay if it was active on chair upholstery
                     if (isChairUpholstery && sceneObject.parentModel?.userData?.overlayState) { // Safe access
                          applyChairOverlay(sceneObject, sceneObject.parentModel.userData.overlayState, false); // Reapply without history
                     }


                     // Refresh panel if needed
                     if (selectedObjects.includes(sceneObject)) showSingleObjectPanelBasedOnSelection();
                     resolve();
                 }, undefined, (err) => { console.error('Error loading bump map from Data URL:', err); reject(err); });
             });
         }
        function revertToDefault(sceneObject, addToHistory = true) {
            const mesh = sceneObject.mesh;
            if (!mesh) return;

             const isChairUpholstery = sceneObject.name === 'ריפוד כיסא';
             const materialToChange = getMaterialToChange(mesh);
             const originalMaterial = sceneObject.originalMaterial; // The initial material(s) when model was loaded
             if (!materialToChange || !originalMaterial) return;

             const firstMatCurrent = Array.isArray(materialToChange) ? materialToChange[0] : materialToChange;
             const firstMatOriginal = Array.isArray(originalMaterial) ? originalMaterial[0] : originalMaterial;
              if (!firstMatCurrent || !firstMatOriginal) return; // Exit if materials are somehow missing


            if (addToHistory) {
                 // Capture current state before reverting
                const beforeState = {
                    color: '#' + firstMatCurrent.color.getHexString(),
                    roughness: firstMatCurrent.roughness,
                    metalness: firstMatCurrent.metalness,
                    opacity: firstMatCurrent.opacity,
                    emissiveIntensity: firstMatCurrent.emissiveIntensity,
                    map: firstMatCurrent.userData.textureDataUrl || null,
                    bumpMap: firstMatCurrent.userData.bumpDataUrl || null,
                    overlay: isChairUpholstery ? sceneObject.parentModel?.userData?.overlayState : undefined // Safe access
                };
                 // Define state after revert (based on original material)
                 const afterEmissiveIntensity = (sceneObject.name === 'פאנל LED') ? 1.5 : (firstMatOriginal.emissiveIntensity || 0);
                 const afterState = {
                    color: '#' + firstMatOriginal.color.getHexString(),
                    roughness: firstMatOriginal.roughness,
                    metalness: firstMatOriginal.metalness,
                    opacity: firstMatOriginal.opacity,
                    emissiveIntensity: afterEmissiveIntensity,
                     // Check if original map/bumpmap had image source
                    map: firstMatOriginal.map?.image?.src || null,
                    bumpMap: firstMatOriginal.bumpMap?.image?.src || null,
                    overlay: undefined // Reverting removes overlay
                };
                 // Use specific history type for chairs
                 if (isChairUpholstery) {
                     addHistory({ type: 'chairRevert', objectData: sceneObject, before: beforeState, after: afterState });
                 } else {
                     addHistory({ type: 'materialRevert', mesh: mesh, before: beforeState, after: afterState });
                 }
             }

             // --- Apply the revert ---

             // Remove overlay first if it's chair upholstery
             if (isChairUpholstery && sceneObject.parentModel?.userData?.overlayState) { // Safe access
                 applyChairOverlay(sceneObject, null, false); // Remove overlay without adding history
                 // The material on the mesh is now the restored base material
             }

             // Now revert the (potentially restored) base material to the original loaded material
             const currentBaseMaterial = getMaterialToChange(mesh); // Get the current material after potential overlay removal
             if (!currentBaseMaterial) return; // Exit if material disappeared

            const applyRevertLogic = (matToChange, matOriginal) => {
                 if (!matOriginal) return;
                 // Clone maps carefully
                 matToChange.map = matOriginal.map ? matOriginal.map.clone() : null;
                 matToChange.bumpMap = matOriginal.bumpMap ? matOriginal.bumpMap.clone() : null;

                matToChange.color.set(matOriginal.color);
                matToChange.metalness = matOriginal.metalness;
                matToChange.roughness = matOriginal.roughness;
                matToChange.opacity = matOriginal.opacity;
                matToChange.transparent = matOriginal.opacity < 1;
                matToChange.bumpScale = matOriginal.bumpScale || 1;

                // Handle emissive for panels
                const defaultIntensity = (sceneObject.name === 'פאנל LED') ? 1.5 : (matOriginal.emissiveIntensity || 0);
                matToChange.emissiveIntensity = defaultIntensity;
                if (sceneObject.name === 'פאנל LED') {
                    matToChange.emissive.setHex(0xFF0000);
                    matToChange.color.setHex(0x330000); // Ensure panel base color resets too
                } else if (matOriginal.emissive) { // Check if original emissive exists
                    matToChange.emissive.set(matOriginal.emissive);
                } else {
                     matToChange.emissive.setHex(0x000000); // Default to black if original was missing
                }

                // Clear custom data - crucial for clean revert
                matToChange.userData = {}; // Clear all user data

                matToChange.needsUpdate = true;
            };

            if (Array.isArray(currentBaseMaterial)) {
                 if (Array.isArray(originalMaterial)) {
                    for (let i = 0; i < currentBaseMaterial.length; i++) {
                        applyRevertLogic(currentBaseMaterial[i], originalMaterial[i]); // Apply original to corresponding clone
                    }
                 } else { // Apply single original to all in array? Apply to first.
                    applyRevertLogic(currentBaseMaterial[0], originalMaterial);
                 }
             } else { // Single material
                 const origMat = Array.isArray(originalMaterial) ? originalMaterial[0] : originalMaterial;
                  if (!origMat) return; // Exit if original is missing
                 applyRevertLogic(currentBaseMaterial, origMat);
             }

            // Update parent model overlay state if it was a chair
            if (isChairUpholstery && sceneObject.parentModel) { // Safe access
                sceneObject.parentModel.userData.overlayState = null;
            }

            // Refresh panel if selected
             if (selectedObjects.includes(sceneObject)) {
                 showSingleObjectPanel(sceneObject);
             }
         }


        // --- Duplication & Deletion ---
        // ... existing functions ...
         function duplicateModel(objectId, addToHistory = true) {
            const targetObject = sceneObjects.find(obj => obj.id === objectId);
            if (!targetObject || !targetObject.parentModel || targetObject.mesh.userData.isLocked) {
                 console.warn("Cannot duplicate locked model or invalid object ID.");
                 return;
            }
            const originalModel = targetObject.parentModel;
            const newModel = originalModel.clone();
            newModel.position.add(new THREE.Vector3(1, 0, 1));
            newModel.userData = JSON.parse(JSON.stringify(originalModel.userData)); // Deep copy userData
            // Reset overlay state for duplicated chairs
            if (newModel.userData.url === CHAIR_MODEL_URL) {
                 newModel.userData.overlayState = null;
            }
            newModel.userData.transform = { position: newModel.position.clone(), rotation: newModel.rotation.clone(), scale: newModel.scale.clone() };

            const newSceneObjects = [];
            newModel.traverse((child) => {
                if (child.isMesh) {
                    child.userData = JSON.parse(JSON.stringify(child.userData)); // Deep copy userData
                    child.userData.isLocked = newModel.userData.isLocked;

                    // Find corresponding original child mesh using name (more reliable after clone than UUID)
                    const originalSceneObject = sceneObjects.find(obj => obj.parentModel === originalModel && obj.mesh.name === child.name);

                    let originalMaterialToClone = originalSceneObject ? getMaterialToChange(originalSceneObject.mesh) : child.material;
                    if (!originalMaterialToClone) return; // Skip if no material

                     // Clone material(s)
                     let newMaterial;
                     if (Array.isArray(originalMaterialToClone)) {
                         newMaterial = originalMaterialToClone.map(mat => mat?.clone()).filter(Boolean); // Clone and filter out nulls
                         // Clear overlay-specific userData from cloned materials
                         newMaterial.forEach(mat => {
                             if (mat.userData) {
                                 delete mat.userData.isOverlay;
                                 delete mat.userData.overlayType;
                                 // Clear originalSeatMaterialProperties on duplicate? YES.
                                 delete mat.userData.originalSeatMaterialProperties;
                             } else {
                                 mat.userData = {};
                             }
                         });
                     } else {
                         newMaterial = originalMaterialToClone.clone();
                         // Clear overlay-specific userData
                         if (newMaterial.userData) {
                             delete newMaterial.userData.isOverlay;
                             delete newMaterial.userData.overlayType;
                             delete newMaterial.userData.originalSeatMaterialProperties;
                         } else {
                             newMaterial.userData = {};
                         }
                     }

                    child.material = newMaterial;
                    child.userData.stableId = originalSceneObject ? originalSceneObject.stableId : child.uuid; // Use original stableId

                    const newSceneObject = {
                        id: child.uuid, // New UUID after clone
                        stableId: child.userData.stableId,
                        name: originalSceneObject ? `${originalSceneObject.name} (עותק)` : `חלק_${globalObjectCounter++}`,
                        mesh: child,
                        // Clone the *original* material definition for the duplicate's revert state
                         originalMaterial: originalSceneObject?.originalMaterial
                            ? (Array.isArray(originalSceneObject.originalMaterial)
                                ? originalSceneObject.originalMaterial.map(m => m?.clone()).filter(Boolean) // Clone array, check for null
                                : originalSceneObject.originalMaterial.clone()) // Clone single
                            : (Array.isArray(child.material) // Fallback to current material if originalSceneObject not found
                                ? child.material.map(m => m?.clone()).filter(Boolean)
                                : child.material?.clone()), // Handle null material case
                        parentModel: newModel
                    };
                    sceneObjects.push(newSceneObject);
                    newSceneObjects.push(newSceneObject);
                }
            });
            scene.add(newModel);

            // Apply animation if original had it
            if (sittingClapAnimation && originalModel.userData.mixer) {
                playAnimationOnModel(newModel, sittingClapAnimation);
            }

            if (addToHistory) addHistory({ type: 'duplicate', newModel: newModel, newSceneObjects: newSceneObjects });
            populateSidebar();
        }
         function duplicateLight(lightHelperObject, addToHistory = true) { const originalLight = lightHelpersMap.get(lightHelperObject.mesh); if (!originalLight) return; const newPosition = lightHelperObject.mesh.position.clone().add(new THREE.Vector3(1.0, 0, 1.0)); let newLightData; if (lightHelperObject.lightType === 'point') newLightData = createPointLight(newPosition, originalLight.intensity, originalLight.distance, originalLight.color, originalLight.castShadow, originalLight.shadow.bias, originalLight.shadow.normalBias); if (newLightData && addToHistory) addHistory({ type: 'duplicateLight', lightType: lightHelperObject.lightType, newLight: newLightData.light, newHelper: newLightData.helper, newSceneObjectData: newLightData.data }); }
         function deleteSelected(addToHistory = true) {
            if (selectedObjects.length === 0) return;
            const deletedModels = [];
            const deletedSceneObjectsGroups = [];
            const deletedLights = [];
            const deletedHelpers = [];
            const deletedLightSceneObjects = [];

            [...selectedObjects].forEach(objectToDeleteData => {
                if (objectToDeleteData.isLightHelper) {
                    const light = lightHelpersMap.get(objectToDeleteData.mesh);
                    if (light) {
                        deletedLights.push(light);
                        deletedHelpers.push(objectToDeleteData.mesh);
                        deletedLightSceneObjects.push(objectToDeleteData);
                        scene.remove(light);
                        scene.remove(objectToDeleteData.mesh);
                        lightHelpersMap.delete(objectToDeleteData.mesh);
                        sceneObjects = sceneObjects.filter(obj => obj !== objectToDeleteData);
                        if(objectToDeleteData.lightType === 'point') pointLights = pointLights.filter(pl => pl.helper !== objectToDeleteData.mesh);
                    }
                } else {
                    const parentModel = objectToDeleteData.parentModel;
                    if (parentModel && !deletedModels.includes(parentModel) && !parentModel.userData.isLocked) {
                        deletedModels.push(parentModel);
                        const objectsInModel = sceneObjects.filter(obj => obj.parentModel === parentModel);
                        deletedSceneObjectsGroups.push(objectsInModel);
                        scene.remove(parentModel);

                        if (parentModel.userData.mixer) {
                            parentModel.userData.mixer.stopAllAction();
                            mixers = mixers.filter(m => m !== parentModel.userData.mixer);
                        }

                        sceneObjects = sceneObjects.filter(obj => obj.parentModel !== parentModel);
                    } else if (parentModel && parentModel.userData.isLocked) {
                        console.warn("Cannot delete locked model:", parentModel.name || parentModel.uuid);
                    }
                }
            });

            if (addToHistory && (deletedModels.length > 0 || deletedLights.length > 0)) {
                addHistory({ type: 'deleteMultiple', deletedModels, deletedSceneObjectsGroups, deletedLights, deletedHelpers, deletedLightSceneObjects });
            }
            deselectObject();
            populateSidebar();
            populateLightList();
        }

        // --- Keyboard Shortcuts ---
        // ... existing onKeyDown ...
         function onKeyDown(event) {
            const activeEl = document.activeElement;
            if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.tagName === 'SELECT')) return;

            if (event.shiftKey && event.key.toLowerCase() === 'd') {
                event.preventDefault();
                if (selectedObjects.length > 0) {
                    const uniqueModelsToDuplicate = new Set();
                    const lightHelpersToDuplicate = [];

                    selectedObjects.forEach(selectedObj => {
                        if (selectedObj.isLightHelper) {
                            lightHelpersToDuplicate.push(selectedObj);
                        } else if (selectedObj.parentModel && !selectedObj.mesh.userData.isLocked) {
                            uniqueModelsToDuplicate.add(selectedObj.parentModel);
                        }
                    });

                    uniqueModelsToDuplicate.forEach(model => {
                        const sceneObject = sceneObjects.find(obj => obj.parentModel === model);
                        if(sceneObject) duplicateModel(sceneObject.id);
                    });

                    lightHelpersToDuplicate.forEach(lightHelper => {
                        duplicateLight(lightHelper);
                    });
                }
                return;
            }

            if (event.ctrlKey || event.metaKey) {
                if (event.key.toLowerCase() === 'z') {
                    event.preventDefault();
                    undo();
                } else if (event.key.toLowerCase() === 'y') {
                    event.preventDefault();
                    redo();
                }
                return;
            }

            switch (event.key.toLowerCase()) {
                case 'z': case 'ז':
                    event.preventDefault();
                    zoomToSelected();
                    break;
                case 'w': case '׳':
                    event.preventDefault();
                    setGizmoMode('translate');
                    break;
                case 'e': case 'ק':
                    event.preventDefault();
                    setGizmoMode('rotate');
                    break;
                case 'r': case 'ר':
                    event.preventDefault();
                    setGizmoMode('scale');
                    break;
                case 'delete': case 'backspace':
                    event.preventDefault();
                    deleteSelected();
                    break;
            }
        }


        // --- Zoom Function ---
        // ... existing functions ...
         function zoomToSelected() { if (selectedObjects.length === 0) return; const box = new THREE.Box3(); selectedObjects.forEach(selectedObj => { const objectToMeasure = selectedObj.parentModel || selectedObj.mesh; if (objectToMeasure) { box.expandByObject(objectToMeasure); } }); if (box.isEmpty()) return; const targetLookAt = box.getCenter(new THREE.Vector3()); const size = box.getSize(new THREE.Vector3()); const maxDim = Math.max(size.x, size.y, size.z); const distance = Math.max(maxDim * 2.5, 5); const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize(); const targetPosition = new THREE.Vector3().addVectors(targetLookAt, direction.multiplyScalar(distance)); const duration = 500; new TWEEN.Tween(camera.position).to(targetPosition, duration).easing(TWEEN.Easing.Quadratic.Out).start(); new TWEEN.Tween(controls.target).to(targetLookAt, duration).easing(TWEEN.Easing.Quadratic.Out).start(); }
         function focusCameraOnChair(chairObjectData) {
             const chairModel = chairObjectData.parentModel;
             if (!chairModel) return;

             const transform = chairModel.userData.transform || { position: chairModel.position, rotation: chairModel.rotation, scale: chairModel.scale };

             const box = new THREE.Box3().setFromObject(chairModel);
             const center = box.getCenter(new THREE.Vector3());
             const size = box.getSize(new THREE.Vector3());

             const offset = new THREE.Vector3(0, size.y * 0.4, -size.z * 1.2);
             const rotationQuaternion = new THREE.Quaternion().setFromEuler(transform.rotation);
             offset.applyQuaternion(rotationQuaternion);
             const targetPosition = center.clone().add(offset);

             const lookAtOffset = new THREE.Vector3(0, size.y * 0.1, size.z * 2);
             lookAtOffset.applyQuaternion(rotationQuaternion);
             const targetLookAt = center.clone().add(lookAtOffset);


             const duration = 700;
             new TWEEN.Tween(camera.position)
                 .to(targetPosition, duration)
                 .easing(TWEEN.Easing.Quadratic.Out)
                 .start();
             new TWEEN.Tween(controls.target)
                 .to(targetLookAt, duration)
                 .easing(TWEEN.Easing.Quadratic.Out)
                 .start();
         }


        // --- History Management ---
        // ... existing functions ...
         function addHistory(action) {
             console.log("Adding History:", action.type, action); // Debug log
             history = history.slice(0, historyIndex + 1);
             history.push(action);
             if (history.length > MAX_HISTORY) history.shift();
             historyIndex = history.length - 1;
             updateHistoryButtons();
        }
        function updateHistoryButtons() { undoBtn.disabled = historyIndex < 0; redoBtn.disabled = historyIndex >= history.length - 1; }
        function undo() { if (historyIndex < 0) return; const action = history[historyIndex]; console.log("Undoing:", action.type, action); applyAction(action, 'before'); historyIndex--; updateHistoryButtons(); }
        function redo() { if (historyIndex >= history.length - 1) return; historyIndex++; const action = history[historyIndex]; console.log("Redoing:", action.type, action); applyAction(action, 'after'); updateHistoryButtons(); }
        function applyAction(action, state) {
            const data = action[state]; // This is the state object (e.g., action.before or action.after)
            switch(action.type) {
                case 'transform': {
                    // ... (transform logic remains the same) ...
                    const obj = action.object;
                    obj.position.copy(data.position);
                    obj.rotation.copy(data.rotation);
                    obj.scale.copy(data.scale);
                    if(obj.userData.transform) {
                        obj.userData.transform.position.copy(data.position);
                        obj.userData.transform.rotation.copy(data.rotation);
                        obj.userData.transform.scale.copy(data.scale);
                    }
                    const actualLight = lightHelpersMap.get(obj);
                    if (actualLight) {
                        actualLight.position.copy(obj.position);
                        updateRangeIndicator();
                    }
                    break;
                }
                case 'material': { // General material change (non-chair specific parts)
                     const material = getMaterialToChange(action.mesh);
                     const sceneObject = sceneObjects.find(obj => obj.mesh === action.mesh);
                     if (!material || !sceneObject) break; // Exit if material/object not found

                     // Wrap async operations in an IIAFE since applyAction is not async
                     (async () => {
                         const applyToMat = async (mat) => { // Keep async for internal await
                             if (!mat) return; // Skip null materials
                             switch(action.property) {
                                 case 'color':
                                     mat.color.set(data); // data is the color string (e.g., "#ff0000")
                                     mat.map = null;
                                     mat.userData.textureDataUrl = null;
                                     break;
                                 case 'roughness': mat.roughness = data; break; // data is the number
                                 case 'metalness': mat.metalness = data; break; // data is the number
                                 case 'opacity':
                                     mat.opacity = data; // data is the number
                                     mat.transparent = data < 1;
                                     break;
                                 case 'emissiveIntensity': mat.emissiveIntensity = data; break; // data is the number
                                 case 'map':
                                     if (data) await applyTextureFromDataUrl(sceneObject, data, false); // Use await
                                     else { mat.map = null; mat.userData.textureDataUrl = null; }
                                     break;
                                 case 'bumpMap':
                                     if (data) await applyBumpMapFromDataUrl(sceneObject, data, false); // Use await
                                     else { mat.bumpMap = null; mat.userData.bumpDataUrl = null; }
                                     break;
                             }
                             mat.needsUpdate = true;
                         };

                         // Handle both single and array materials within the async function
                         if (Array.isArray(material)) {
                             for (const mat of material) await applyToMat(mat); // Use await with for...of
                         } else {
                             await applyToMat(material); // Use await
                         }

                         if (selectedObjects.includes(sceneObject)) showSingleObjectPanelBasedOnSelection(); // Refresh panel after async ops complete
                     })(); // Immediately invoke the async function
                    break;
                }
                 case 'chairColor': { // Specific history for chair upholstery base color
                     const upholsteryObject = action.objectData;
                     if (!upholsteryObject) break;
                     applyChairUpholsteryColor(upholsteryObject, data.color, false); // Apply color without adding history
                     // Re-apply overlay if it existed in this state
                     applyChairOverlay(upholsteryObject, data.overlay, false);
                     if (selectedObjects.includes(upholsteryObject)) showSingleObjectPanel(upholsteryObject); // Refresh panel
                     break;
                 }
                 case 'chairOverlay': { // Specific history for chair overlay change
                    const upholsteryObject = action.objectData;
                    if (!upholsteryObject) break;
                    // Apply the overlay state first
                    applyChairOverlay(upholsteryObject, data.overlay, false);
                    // Then, if *not* applying an overlay (i.e., removing it or going to a state without one),
                    // restore the base material properties *from this history state*
                    if (!data.overlay) {
                         const material = getMaterialToChange(upholsteryObject.mesh);
                         const mat = Array.isArray(material) ? material[0] : material;
                         if (mat && !mat.userData.isOverlay) { // Ensure we are modifying the base material
                             mat.color.set(data.color);
                             mat.roughness = data.roughness;
                             mat.metalness = data.metalness;
                             mat.opacity = data.opacity;
                             mat.transparent = data.opacity < 1;
                             mat.userData.textureDataUrl = data.map; // Store URL
                             mat.userData.bumpDataUrl = data.bumpMap;   // Store URL

                             // Need to re-apply textures/bumps based on the URLs in 'data' asynchronously
                             const reapplyTextures = async () => {
                                 if (data.map) await applyTextureFromDataUrl(upholsteryObject, data.map, false);
                                 else mat.map = null;
                                 if (data.bumpMap) await applyBumpMapFromDataUrl(upholsteryObject, data.bumpMap, false);
                                 else mat.bumpMap = null;
                                 mat.needsUpdate = true;
                                 if (selectedObjects.includes(upholsteryObject)) showSingleObjectPanel(upholsteryObject); // Refresh panel after async
                             };
                             reapplyTextures(); // Run async without awaiting applyAction

                         }
                    } else {
                         // If applying an overlay, just refresh the panel if selected
                         if (selectedObjects.includes(upholsteryObject)) showSingleObjectPanel(upholsteryObject);
                    }
                     break;
                 }
                 case 'chairTexture': // History for chair upholstery texture
                 case 'chairBump': {  // History for chair upholstery bump map
                     const upholsteryObject = action.objectData;
                     if (!upholsteryObject) break;
                     const isBump = action.type === 'chairBump';
                     const mapUrl = isBump ? data.bumpMap : data.map;
                     const applyFunc = isBump ? applyBumpMapFromDataUrl : applyTextureFromDataUrl;

                     // Apply the texture/bump asynchronously
                     const applyMap = async () => {
                         if (mapUrl) {
                             await applyFunc(upholsteryObject, mapUrl, false); // Apply map without history
                         } else { // Remove the map
                             const material = getMaterialToChange(upholsteryObject.mesh);
                             const mat = Array.isArray(material) ? material[0] : material;
                             if (mat) {
                                 if (isBump) mat.bumpMap = null; else mat.map = null;
                                 if (isBump) mat.userData.bumpDataUrl = null; else mat.userData.textureDataUrl = null;
                                // If removing texture, restore base color if stored
                                 if (!isBump && mat.userData.originalSeatMaterialProperties?.color) {
                                      mat.color.set(mat.userData.originalSeatMaterialProperties.color);
                                 }
                                 mat.needsUpdate = true;
                             }
                         }
                         // Re-apply overlay AFTER texture/bump application
                         applyChairOverlay(upholsteryObject, data.overlay, false);
                         if (selectedObjects.includes(upholsteryObject)) showSingleObjectPanel(upholsteryObject); // Refresh panel
                     };
                     applyMap(); // Run async
                     break;
                 }
                case 'chairRevert': // History for reverting chair material
                case 'materialRevert': { // History for reverting general material
                    const sceneObject = action.type === 'chairRevert' ? action.objectData : sceneObjects.find(obj => obj.mesh === action.mesh);
                    if (!sceneObject) break;

                    const material = getMaterialToChange(sceneObject.mesh);
                    if (!material) break;

                    // Remove overlay first if chair revert
                    if (action.type === 'chairRevert') {
                        applyChairOverlay(sceneObject, null, false); // Remove overlay without history
                    }

                    // Get the potentially updated material instance AFTER overlay removal
                    const currentMaterialInstance = getMaterialToChange(sceneObject.mesh);
                    if (!currentMaterialInstance) break;

                    // Apply non-texture properties synchronously
                     const applyNonTextureProps = (mat) => {
                         if (!mat) return;
                         mat.color.set(data.color); // data is the state object (before or after)
                         mat.roughness = data.roughness;
                         mat.metalness = data.metalness;
                         mat.opacity = data.opacity;
                         mat.transparent = data.opacity < 1;
                         mat.emissiveIntensity = data.emissiveIntensity;
                         // Handle panel emissive color specifically if needed
                         if (sceneObject.name === 'פאנל LED' && mat.emissiveIntensity > 0) {
                             mat.emissive.setHex(0xFF0000);
                             mat.color.setHex(0x330000);
                         } else if (sceneObject.name === 'פאנל LED') {
                             mat.emissive.setHex(0x000000); // Reset emissive if intensity is 0
                         } else if (data.emissive) { // Restore original emissive color if available in data
                            mat.emissive.set(data.emissive); // Assuming data structure holds original emissive
                         } else {
                            mat.emissive.setHex(0x000000); // Fallback
                         }
                         // Clear custom data URLs, they will be reapplied if needed
                         mat.userData.textureDataUrl = null;
                         mat.userData.bumpDataUrl = null;
                         // Clear stored props when reverting
                         delete mat.userData.originalSeatMaterialProperties;
                         delete mat.userData.isOverlay;
                         delete mat.userData.overlayType;
                         mat.needsUpdate = true; // Update after basic props
                     };

                    if (Array.isArray(currentMaterialInstance)) {
                        currentMaterialInstance.forEach(applyNonTextureProps);
                    } else {
                        applyNonTextureProps(currentMaterialInstance);
                    }

                    // Apply textures/bumps asynchronously based on the 'data' state
                    const applyTexturesAsync = async () => {
                         if (data.map) {
                             await applyTextureFromDataUrl(sceneObject, data.map, false);
                         } else { // Explicitly remove map if data.map is null/undefined
                             const currentMat = getMaterialToChange(sceneObject.mesh); // Get potentially updated material instance
                             if (Array.isArray(currentMat)) currentMat.forEach(m => { if(m) { m.map = null; m.needsUpdate = true; }});
                             else if (currentMat) { currentMat.map = null; currentMat.needsUpdate = true; }
                         }
                         if (data.bumpMap) {
                             await applyBumpMapFromDataUrl(sceneObject, data.bumpMap, false);
                         } else { // Explicitly remove bump map
                            const currentMat = getMaterialToChange(sceneObject.mesh);
                             if (Array.isArray(currentMat)) currentMat.forEach(m => { if(m) { m.bumpMap = null; m.needsUpdate = true;} });
                             else if (currentMat) { currentMat.bumpMap = null; currentMat.needsUpdate = true; }
                         }
                         // Final refresh after potential async ops
                         if (selectedObjects.includes(sceneObject)) showSingleObjectPanel(sceneObject);
                    };

                     applyTexturesAsync(); // Don't await here, let it run

                    break;
                }
                // ... other cases (duplicate, duplicateLight, lightProperty, deleteMultiple, addLight, loadScene) remain the same ...
                case 'duplicate': {
                    if (state === 'after') {
                        scene.add(action.newModel);
                        sceneObjects.push(...action.newSceneObjects);
                        if (sittingClapAnimation && action.newModel.userData.url.endsWith('.fbx')) {
                            playAnimationOnModel(action.newModel, sittingClapAnimation);
                        }
                    } else {
                        scene.remove(action.newModel);
                        if (action.newModel.userData.mixer) {
                            action.newModel.userData.mixer.stopAllAction();
                            mixers = mixers.filter(m => m !== action.newModel.userData.mixer);
                        }
                        sceneObjects = sceneObjects.filter(obj => !action.newSceneObjects.includes(obj));
                    }
                    populateSidebar();
                    break;
                }
                case 'duplicateLight': {
                    if (state === 'after') {
                        scene.add(action.newLight);
                        scene.add(action.newHelper);
                        lightHelpersMap.set(action.newHelper, action.newLight);
                        sceneObjects.push(action.newSceneObjectData);
                        if(action.lightType === 'point') pointLights.push({ light: action.newLight, helper: action.newHelper, data: action.newSceneObjectData });
                    } else {
                        scene.remove(action.newLight);
                        scene.remove(action.newHelper);
                        lightHelpersMap.delete(action.newHelper);
                        sceneObjects = sceneObjects.filter(obj => obj !== action.newSceneObjectData);
                        if(action.lightType === 'point') pointLights = pointLights.filter(pl => pl.helper !== action.newHelper);
                    }
                    populateLightList();
                    break;
                }
                case 'lightProperty': {
                    const light = action.light;
                    if (action.property === 'color') {
                        light.color.set(data);
                        const helper = pointLights.find(pl => pl.light === light)?.helper;
                        if (helper && helper.material) helper.material.color.set(data);
                    } else if (action.isShadowProperty) {
                        if (light.shadow.map) { light.shadow.map.dispose(); light.shadow.map = null; }
                        light.shadow[action.property] = data;
                        if(action.property === 'castShadow') light.castShadow = data;
                    } else {
                        light[action.property] = data; // Use action.property here
                    }
                    const lastSelected = selectedObjects.length > 0 ? selectedObjects[selectedObjects.length - 1] : null;
                    if (lastSelected && lightHelpersMap.get(lastSelected.mesh) === light) {
                        if (action.property === 'intensity') { plIntensitySlider.value = data; plIntensityValueSpan.textContent = data.toFixed(1); }
                        else if (action.property === 'distance') { plDistanceSlider.value = data; plDistanceValueSpan.textContent = data.toFixed(1); updateRangeIndicator(); }
                        else if (action.property === 'color') { plColorPicker.value = data; }
                        else if (action.property === 'castShadow') { plCastShadowCheckbox.checked = data; }
                        else if (action.property === 'bias') { plShadowBiasSlider.value = data; }
                        else if (action.property === 'normalBias') { plShadowNormalBiasSlider.value = data; }
                    }
                    break;
                }
                case 'deleteMultiple': {
                    if (state === 'after') {
                        action.deletedModels.forEach(model => {
                            scene.remove(model);
                            if (model.userData.mixer) {
                                model.userData.mixer.stopAllAction();
                                mixers = mixers.filter(m => m !== model.userData.mixer);
                            }
                        });
                        action.deletedLights.forEach(light => scene.remove(light));
                        action.deletedHelpers.forEach(helper => {
                            scene.remove(helper);
                            lightHelpersMap.delete(helper);
                        });
                        sceneObjects = sceneObjects.filter(obj => !action.deletedSceneObjectsGroups.flat().includes(obj) && !action.deletedLightSceneObjects.includes(obj));
                        pointLights = pointLights.filter(pl => !action.deletedHelpers.includes(pl.helper));
                        deselectObject();
                    } else {
                        action.deletedModels.forEach(model => {
                            scene.add(model);
                            if (sittingClapAnimation && model.userData.url.endsWith('.fbx')) {
                                playAnimationOnModel(model, sittingClapAnimation);
                            }
                        });
                        action.deletedLights.forEach(light => scene.add(light));
                        action.deletedHelpers.forEach((helper, index) => {
                            scene.add(helper);
                            lightHelpersMap.set(helper, action.deletedLights[index]);
                        });
                        sceneObjects.push(...action.deletedSceneObjectsGroups.flat());
                        sceneObjects.push(...action.deletedLightSceneObjects);
                        action.deletedLightSceneObjects.forEach((lightSceneObj, index) => {
                            if(lightSceneObj.lightType === 'point') {
                                pointLights.push({ light: action.deletedLights[index], helper: action.deletedHelpers[index], data: lightSceneObj });
                            }
                        });
                    }
                    populateSidebar();
                    populateLightList();
                    break;
                }
                case 'addLight': {
                    if (state === 'after') {
                        scene.add(action.addedLight);
                        scene.add(action.addedHelper);
                        lightHelpersMap.set(action.addedHelper, action.addedLight);
                        sceneObjects.push(action.addedSceneObjectData);
                        if (action.lightType === 'point') pointLights.push({ light: action.addedLight, helper: action.addedHelper, data: action.addedSceneObjectData });
                    } else {
                        scene.remove(action.addedLight);
                        scene.remove(action.addedHelper);
                        lightHelpersMap.delete(action.addedHelper);
                        sceneObjects = sceneObjects.filter(obj => obj !== action.addedSceneObjectData);
                        if (action.lightType === 'point') pointLights = pointLights.filter(pl => pl.helper !== action.addedHelper);
                    }
                    populateLightList();
                    break;
                }
                 case 'loadScene': {
                    // Re-apply the entire scene data for this state
                     // Use an IIAFE to handle async within the synchronous applyAction
                     (async () => {
                         await applySceneData(data); // Pass the scene data object for this state
                         // Note: This won't perfectly restore selection or panel states from before the load.
                         updateHistoryButtons(); // Update buttons after async operation completes
                     })();
                    break;
                }
            }
        }


        // --- Save & Load ---
        // ... existing saveScene, loadSceneFromFile, loadPresetScene, applySceneData, addDefaultLights, resetSceneToDefault ...
        function saveScene() {
            // ... (save sceneConfig as before) ...
            const sceneConfig = {
                pointLights: pointLights.map(pl => ({
                    intensity: pl.light.intensity,
                    distance: pl.light.distance,
                    position: pl.light.position.toArray(),
                    color: '#' + pl.light.color.getHexString(),
                    castShadow: pl.light.castShadow,
                    shadowBias: pl.light.shadow.bias,
                    shadowNormalBias: pl.light.shadow.normalBias
                })),
            };

            const models = [];
            const processedModels = new Set();
            sceneObjects.forEach(obj => {
                if (!obj.parentModel || obj.isLightHelper || processedModels.has(obj.parentModel.uuid)) return;

                const parentModel = obj.parentModel;
                const transformData = parentModel.userData.transform || { position: parentModel.position, rotation: parentModel.rotation, scale: parentModel.scale };
                 const isChair = parentModel.userData.url === CHAIR_MODEL_URL;

                const modelData = {
                    url: parentModel.userData.url,
                    transform: {
                        position: transformData.position.toArray(),
                        rotation: [transformData.rotation.x, transformData.rotation.y, transformData.rotation.z], // Save as array
                        scale: transformData.scale.toArray()
                    },
                    materials: {},
                    hasAnimation: !!parentModel.userData.mixer,
                    overlayState: isChair ? (parentModel.userData.overlayState || null) : undefined // Save overlay state for chairs
                };

                const childMeshes = sceneObjects.filter(o => o.parentModel === parentModel);
                childMeshes.forEach(childObj => {
                    const material = getMaterialToChange(childObj.mesh);
                    const firstMat = Array.isArray(material) ? material[0] : material;
                    if (firstMat) {
                         // Save base material properties, potentially from stored userData if overlay is active
                         let propsToSave = {
                            color: '#' + firstMat.color.getHexString(),
                            roughness: firstMat.roughness,
                            metalness: firstMat.metalness,
                            opacity: firstMat.opacity,
                            emissiveIntensity: firstMat.emissiveIntensity,
                            textureDataUrl: firstMat.userData.textureDataUrl || null,
                            bumpDataUrl: firstMat.userData.bumpDataUrl || null
                         };

                         // If it's upholstery with stored properties, save those as the base
                         if (childObj.name === 'ריפוד כיסא' && firstMat.userData.originalSeatMaterialProperties) {
                              propsToSave.color = firstMat.userData.originalSeatMaterialProperties.color || propsToSave.color;
                              propsToSave.roughness = firstMat.userData.originalSeatMaterialProperties.roughness !== undefined ? firstMat.userData.originalSeatMaterialProperties.roughness : propsToSave.roughness;
                              propsToSave.metalness = firstMat.userData.originalSeatMaterialProperties.metalness !== undefined ? firstMat.userData.originalSeatMaterialProperties.metalness : propsToSave.metalness;
                              propsToSave.opacity = firstMat.userData.originalSeatMaterialProperties.opacity !== undefined ? firstMat.userData.originalSeatMaterialProperties.opacity : propsToSave.opacity;
                              propsToSave.textureDataUrl = firstMat.userData.originalSeatMaterialProperties.textureDataUrl || propsToSave.textureDataUrl;
                              propsToSave.bumpDataUrl = firstMat.userData.originalSeatMaterialProperties.bumpDataUrl || propsToSave.bumpDataUrl;
                         }


                         // Save only necessary props (exclude maps if color is set etc.)
                         const finalProps = {
                            roughness: propsToSave.roughness,
                            metalness: propsToSave.metalness,
                            opacity: propsToSave.opacity,
                            emissiveIntensity: propsToSave.emissiveIntensity,
                         };
                         if (propsToSave.textureDataUrl) {
                            finalProps.textureDataUrl = propsToSave.textureDataUrl;
                            finalProps.color = '#ffffff'; // Color is white when texture applied
                         } else {
                            finalProps.color = propsToSave.color;
                         }
                         if (propsToSave.bumpDataUrl) {
                             finalProps.bumpDataUrl = propsToSave.bumpDataUrl;
                         }

                        modelData.materials[childObj.stableId] = finalProps;
                    }
                });
                models.push(modelData);
                processedModels.add(parentModel.uuid);
            });
            const finalData = { sceneConfig, models };
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(finalData));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "scene_state.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }
         function loadSceneFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const finalData = JSON.parse(e.target.result);
                     const beforeData = getCurrentSceneDataForHistory(); // Capture state before loading
                    await applySceneData(finalData); // Refactored logic
                     addHistory({ type: 'loadScene', beforeData: beforeData, afterData: finalData }); // Add load event to history

                } catch (err) {
                    console.error("Error loading JSON file:", err);
                    alert("שגיאה: קובץ סצנה לא תקין.");
                }
            };
            reader.readAsText(file);
            event.target.value = null; // Reset file input
        }
        async function loadPresetScene() {
            loadPresetBtn.disabled = true;
            loadPresetBtn.textContent = 'טוען הדגמה...';
            try {
                 const beforeData = getCurrentSceneDataForHistory(); // Capture state before loading
                const response = await fetch(PRESET_SCENE_URL);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const finalData = await response.json();
                await applySceneData(finalData);
                 addHistory({ type: 'loadScene', beforeData: beforeData, afterData: finalData }); // Add load event to history

            } catch (err) {
                console.error("Error loading preset scene:", err);
                alert("שגיאה בטעינת סצנת הדגמה.");
            } finally {
                 loadPresetBtn.disabled = false;
                 loadPresetBtn.textContent = 'טען סצנת הדגמה (kneeset_28)';
            }
        }
        // Refactored applySceneData - now used by load, undo/redo for load
        async function applySceneData(finalData) {
            console.log("Applying scene data:", finalData);

            // 1. Clear Lights (Synchronous)
            pointLights.forEach(pl => { scene.remove(pl.light); scene.remove(pl.helper); lightHelpersMap.delete(pl.helper); });
            pointLights = [];
            // Keep light helpers in sceneObjects temporarily, loadAllModels will handle removal if needed.
            // sceneObjects = sceneObjects.filter(obj => !obj.isLightHelper); // Don't filter here

            // 2. Add Lights from finalData (Synchronous)
            const config = finalData.sceneConfig;
            if (config?.pointLights?.length > 0) {
                 config.pointLights.forEach(plData => {
                     const color = plData.color ? plData.color : 0xffffff;
                     const castShadow = plData.castShadow !== undefined ? plData.castShadow : false;
                     const shadowBias = plData.shadowBias !== undefined ? plData.shadowBias : 0;
                     const shadowNormalBias = plData.shadowNormalBias !== undefined ? plData.shadowNormalBias : 0.05;
                     createPointLight( new THREE.Vector3().fromArray(plData.position), plData.intensity, plData.distance, color, castShadow, shadowBias, shadowNormalBias);
                 });
            } else {
                 addDefaultLights(); // Add defaults if none specified
            }
            scene.environment = null; // Ensure environment is cleared

             // 3. Load Models (Asynchronous) - This clears old models internally now
             // Pass only the models part of finalData
            await loadAllModels(finalData.models || []);

            // 4. Update UI (Synchronous - after async loadAllModels completes)
            populateSidebar(); // Repopulate with newly loaded objects
            populateLightList(); // Repopulate with newly loaded lights
            deselectObject(); // Deselect after load
            closeSinglePanels();
            // history = []; // Don't clear history here, undo/redo handles it
            // historyIndex = -1;
            // updateHistoryButtons();
            console.log("Scene data applied successfully.");
        }
         function addDefaultLights() {
             createPointLight(new THREE.Vector3(5, 15, 5), 100, 100, 0xffffff, true, 0, 0.05);
             createPointLight(new THREE.Vector3(-5, 15, 5), 100, 100, 0xffffff, true, 0, 0.05);
             createPointLight(new THREE.Vector3(5, 15, -5), 100, 100, 0xffffff, false, 0, 0.05);
             createPointLight(new THREE.Vector3(-5, 15, -5), 100, 100, 0xffffff, false, 0, 0.05);
             createPointLight(new THREE.Vector3(10, 15, 10), 100, 100, 0xffffff, false, 0, 0.05);
             createPointLight(new THREE.Vector3(-10, 15, 10), 100, 100, 0xffffff, false, 0, 0.05);
             createPointLight(new THREE.Vector3(10, 15, -10), 100, 100, 0xffffff, false, 0, 0.05);
             createPointLight(new THREE.Vector3(-10, 15, -10), 100, 100, 0xffffff, false, 0, 0.05);
        }
        async function resetSceneToDefault(addToHistory = true) { // Default to true now? Or keep false? Let's keep false for initial load.
             const beforeData = getCurrentSceneDataForHistory(); // Capture state before reset

            // Clear lights
             pointLights.forEach(pl => { scene.remove(pl.light); scene.remove(pl.helper); lightHelpersMap.delete(pl.helper); });
            pointLights = [];
            sceneObjects = sceneObjects.filter(obj => !obj.isLightHelper);

            // Add default lights
            addDefaultLights();

            // Load default models (clears existing non-light models)
            await loadAllModels(); // Call without arguments

            // Reset camera/controls
            camera.position.set(10, 10, 10);
            controls.target.set(0, 2, 0);

            // Update UI
            populateSidebar();
            populateLightList();
            deselectObject();
            closeSinglePanels();

            console.log("Scene reset to default.");

            // Add to history IF requested (usually only when user explicitly clicks reset)
             if (addToHistory) {
                 const afterData = getCurrentSceneDataForHistory();
                 addHistory({ type: 'loadScene', beforeData: beforeData, afterData: afterData });
                 // Clear future history after a reset that's added to history
                 history = history.slice(0, historyIndex + 1);
                 updateHistoryButtons();
             } else {
                  // If NOT adding to history (like initial load), clear history completely
                  history = [];
                  historyIndex = -1;
                  updateHistoryButtons();
             }
        }
         // Helper to get current scene state for history
         function getCurrentSceneDataForHistory() {
             // This is similar to saveScene but doesn't trigger download
            const sceneConfig = {
                 pointLights: pointLights.map(pl => ({ /* ... light data ... */
                    intensity: pl.light.intensity, distance: pl.light.distance, position: pl.light.position.toArray(), color: '#' + pl.light.color.getHexString(), castShadow: pl.light.castShadow, shadowBias: pl.light.shadow.bias, shadowNormalBias: pl.light.shadow.normalBias
                 })),
             };
             const models = [];
             const processedModels = new Set();
             sceneObjects.forEach(obj => {
                 if (!obj.parentModel || obj.isLightHelper || processedModels.has(obj.parentModel.uuid)) return;
                 const parentModel = obj.parentModel;
                 const transformData = parentModel.userData.transform || { position: parentModel.position, rotation: parentModel.rotation, scale: parentModel.scale };
                 const isChair = parentModel.userData.url === CHAIR_MODEL_URL;
                 const modelData = { /* ... model data including materials and overlayState ... */
                     url: parentModel.userData.url,
                     transform: { position: transformData.position.toArray(), rotation: [transformData.rotation.x, transformData.rotation.y, transformData.rotation.z], scale: transformData.scale.toArray() },
                     materials: {},
                     hasAnimation: !!parentModel.userData.mixer,
                     overlayState: isChair ? (parentModel.userData.overlayState || null) : undefined
                 };
                 const childMeshes = sceneObjects.filter(o => o.parentModel === parentModel);
                 childMeshes.forEach(childObj => {
                     const material = getMaterialToChange(childObj.mesh);
                     const firstMat = Array.isArray(material) ? material[0] : material;
                     if (firstMat) {
                         let propsToSave = { /* ... capture props like in saveScene ... */
                            color: '#' + firstMat.color.getHexString(), roughness: firstMat.roughness, metalness: firstMat.metalness, opacity: firstMat.opacity, emissiveIntensity: firstMat.emissiveIntensity, textureDataUrl: firstMat.userData.textureDataUrl || null, bumpDataUrl: firstMat.userData.bumpDataUrl || null
                         };
                         if (childObj.name === 'ריפוד כיסא' && firstMat.userData.originalSeatMaterialProperties) {
                             propsToSave.color = firstMat.userData.originalSeatMaterialProperties.color || propsToSave.color; /* ... copy other stored props ... */
                              propsToSave.roughness = firstMat.userData.originalSeatMaterialProperties.roughness !== undefined ? firstMat.userData.originalSeatMaterialProperties.roughness : propsToSave.roughness; propsToSave.metalness = firstMat.userData.originalSeatMaterialProperties.metalness !== undefined ? firstMat.userData.originalSeatMaterialProperties.metalness : propsToSave.metalness; propsToSave.opacity = firstMat.userData.originalSeatMaterialProperties.opacity !== undefined ? firstMat.userData.originalSeatMaterialProperties.opacity : propsToSave.opacity; propsToSave.textureDataUrl = firstMat.userData.originalSeatMaterialProperties.textureDataUrl || propsToSave.textureDataUrl; propsToSave.bumpDataUrl = firstMat.userData.originalSeatMaterialProperties.bumpDataUrl || propsToSave.bumpDataUrl;
                         }
                         const finalProps = { /* ... build finalProps like in saveScene ... */
                             roughness: propsToSave.roughness, metalness: propsToSave.metalness, opacity: propsToSave.opacity, emissiveIntensity: propsToSave.emissiveIntensity,
                         };
                         if (propsToSave.textureDataUrl) { finalProps.textureDataUrl = propsToSave.textureDataUrl; finalProps.color = '#ffffff'; } else { finalProps.color = propsToSave.color; }
                         if (propsToSave.bumpDataUrl) { finalProps.bumpDataUrl = propsToSave.bumpDataUrl; }

                         modelData.materials[childObj.stableId] = finalProps;
                     }
                 });
                 models.push(modelData);
                 processedModels.add(parentModel.uuid);
             });
             return { sceneConfig, models };
         }


        // --- Rendering Loop & Resize ---
        // ... existing onWindowResize, animate ...
         function onWindowResize() {
            const width = sceneContainer.clientWidth;
            const height = sceneContainer.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            composer.setSize(width, height);

             // Update panel positions/sizes for mobile/desktop toggle
            const isMobile = window.innerWidth < 768;
            const topMenuBar = document.getElementById('top-menu-bar');
            const topBarHeight = topMenuBar ? topMenuBar.offsetHeight : 60; // Recalculate height

            allPanels.forEach(panel => {
                 // Reset inline styles related to dragging/positioning before applying new ones
                 panel.style.position = 'fixed'; // Ensure it's fixed

                 if (!panel.classList.contains('hidden')) { // Only adjust visible panels
                     if (isMobile) {
                         panel.style.top = `${topBarHeight + 10}px`;
                         panel.style.left = '50%';
                         panel.style.transform = 'translateX(-50%)';
                         panel.style.right = 'auto'; // Reset right
                         panel.style.bottom = 'auto'; // Reset bottom
                         panel.style.maxHeight = `calc(100vh - ${topBarHeight + 20}px)`;
                         panel.style.width = '91.666667%'; // w-11/12
                         panel.style.maxWidth = '20rem'; // max-w-xs
                     } else {
                         // Reset mobile styles and apply desktop defaults if needed
                         panel.style.width = 'auto'; // Reset width
                         panel.style.maxWidth = '20rem'; // Keep max-w-xs (or adjust if needed)

                         // Check if it's a secondary panel
                         const isSecondaryPanel = panel === singleObjectPanel || panel === pointLightPanel;
                         // Keep current position if already dragged, otherwise reset
                         // Check if left style indicates it was centered or not set
                         if (!panel.style.left || panel.style.left === '50%') {
                             if (isSecondaryPanel) {
                                 panel.style.left = '1.25rem'; // left-5 (approx 20px)
                                 panel.style.right = 'auto';
                                 panel.style.transform = 'translateY(-50%)'; // Vertically center
                                 panel.style.top = '50%';
                                 panel.style.maxHeight = '80vh';
                             } else {
                                 panel.style.right = '1.25rem'; // right-5
                                 panel.style.left = 'auto';
                                 panel.style.transform = ''; // Clear transform
                                 panel.style.top = `${topBarHeight + 10}px`; // Position below top bar
                                 panel.style.maxHeight = '80vh'; // Reset max height potentially
                             }
                         } else {
                              // If already dragged (has style.left and it's not 50%), just ensure top is valid
                              const currentTop = parseFloat(panel.style.top);
                              if(currentTop < topBarHeight + 10) {
                                  panel.style.top = `${topBarHeight + 10}px`;
                              }
                               panel.style.maxHeight = '80vh'; // Ensure max height is reset
                               // Ensure transform is cleared if it exists from mobile
                               panel.style.transform = '';
                         }
                     }
                 }
                 // Re-apply draggable logic (checks internally if mobile)
                 makeDraggable(panel);
             });
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();

            const delta = clock.getDelta();
            for ( const mixer of mixers ) {
                mixer.update( delta );
            }

            if (controls && knessetBounds) {
                const target = controls.target;
                const clampedX = THREE.MathUtils.clamp(target.x, knessetBounds.min.x + boundsPadding, knessetBounds.max.x - boundsPadding);
                const clampedZ = THREE.MathUtils.clamp(target.z, knessetBounds.min.z + boundsPadding, knessetBounds.max.z - boundsPadding);
                const clampedY = Math.max(target.y, 0.5);

                 if (target.x !== clampedX || target.z !== clampedZ || target.y !== clampedY) {
                     controls.target.set(clampedX, clampedY, clampedZ);
                 }
            }

            composer.render();
        }

    </script>
</body>
</html>

