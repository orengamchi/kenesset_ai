<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>עורך סצנת תלת-ממד</title>
    <!-- טעינת Tailwind CSS לעיצוב הממשק -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            overflow: hidden; /* מניעת גלילה */
            direction: rtl; /* כיוון מימין לשמאל */
            background-color: #1F2937; /* bg-gray-800 */
        }
        #scene-container {
            width: 100vw;
            height: 100vh;
            background-color: #000000; /* רקע שחור */
            cursor: default;
        }
        canvas {
            display: block;
        }
        /* סגנון לאובייקט שנבחר */
        .selected-object {
            border: 2px solid #34D399; /* emerald-400 */
            background-color: #374151; /* bg-gray-700 */
        }
        /* עיצוב כפתורי העלאת קובץ */
        .texture-upload-input, .bump-upload-input {
            width: 100%;
            font-size: 0.875rem; /* text-sm */
            color: #D1D5DB; /* text-gray-300 */
        }
        .texture-upload-input::file-selector-button,
        .bump-upload-input::file-selector-button {
            margin-left: 0.5rem; /* file:mr-2 */
            padding: 0.25rem 0.5rem; /* file:py-1 file:px-2 */
            border-radius: 0.25rem; /* file:rounded */
            border-width: 0; /* file:border-0 */
            font-size: 0.875rem; /* file:text-sm */
            font-weight: 600; /* file:font-semibold */
            background-color: #2563EB; /* file:bg-blue-600 */
            color: #ffffff; /* file:text-white */
            cursor: pointer;
        }
        .texture-upload-input::file-selector-button:hover,
        .bump-upload-input::file-selector-button:hover {
            background-color: #1D4ED8; /* hover:file:bg-blue-700 */
        }

        /* הסתרת סרגלי גלילה (Webkit) - כללי */
        .hide-scrollbar::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        .hide-scrollbar {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }


        /* סגנון לכפתורי גיזמו פעילים */
        .gizmo-btn.active {
            background-color: #2563EB; /* bg-blue-600 */
        }

        #toggle-light-helpers-btn.active {
            background-color: #2563EB; /* bg-blue-600 */
        }

        /* סגנון לכפתורים מושבתים */
        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* סגנון לתיבת סימון מושבתת */
         input[type="checkbox"]:disabled + label {
            opacity: 0.5;
            cursor: not-allowed;
        }
        input[type="checkbox"]:disabled {
            cursor: not-allowed;
        }


    </style>
</head>
<body class="bg-gray-800">

    <!-- סרגל תפריטים עליון -->
    <div id="top-menu-bar-wrapper" class="fixed top-0 left-0 right-0 z-50 overflow-x-auto hide-scrollbar bg-gray-800/70 backdrop-blur-sm shadow-lg">
        <div id="top-menu-bar" class="flex justify-start sm:justify-center p-2 space-x-2 whitespace-nowrap min-w-max sm:min-w-0">
            <!-- כפתור סצנה (שמור/טען) -->
            <button id="scene-btn" class="p-3 text-white rounded-full hover:bg-gray-700 transition flex-shrink-0" title="סצנה">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3l-4-4-4 4zM8 7V5c0-1.1.9-2 2-2h4a2 2 0 012 2v2M8 7h8"></path></svg>
            </button>
            <!-- כפתור תאורה -->
            <button id="lighting-btn" class="p-3 text-white rounded-full hover:bg-gray-700 transition flex-shrink-0" title="תאורה">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m12.728 0l-.707.707M12 21v-1m0-16a9 9 0 11-9 9h4.673c.11.02.22.04.33.06A9 9 0 0112 3z"></path></svg>
            </button>
            <!-- כפתור הצג/הסתר עזרי תאורה -->
            <button id="toggle-light-helpers-btn" class="p-3 text-white rounded-full hover:bg-gray-700 transition active flex-shrink-0" title="הצג/הסתר עזרי תאורה">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
            </button>
            <!-- כפתור אובייקטים -->
            <button id="objects-btn" class="p-3 text-white rounded-full hover:bg-gray-700 transition flex-shrink-0" title="אובייקטים">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16"></path></svg>
            </button>
             <!-- [נמחק] כפתור אפקטים -->

            <!-- קו הפרדה -->
            <div class="border-l border-gray-600 h-10 my-auto mx-2 flex-shrink-0"></div>

            <!-- כפתורי היסטוריה -->
            <button id="undo-btn" class="p-3 text-white rounded-full hover:bg-gray-700 transition flex-shrink-0" title="בטל (Ctrl+Z)" disabled>
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
            </button>
            <button id="redo-btn" class="p-3 text-white rounded-full hover:bg-gray-700 transition flex-shrink-0" title="בצע שוב (Ctrl+Y)" disabled>
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>
            </button>

            <!-- קו הפרדה -->
            <div class="border-l border-gray-600 h-10 my-auto mx-2 flex-shrink-0"></div>

            <!-- כפתורי גיזמו -->
            <button id="translate-btn" class="gizmo-btn p-3 text-white rounded-full hover:bg-gray-700 transition active flex-shrink-0" title="הזזה (W)">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 4H3v3m0-3l4 4M21 3h-7v3m7-3l-4 4M3 21h7v-3M3 21l4-4m14 4h-7v-3m7 3l-4-4"></path></svg>
            </button>
            <button id="rotate-btn" class="gizmo-btn p-3 text-white rounded-full hover:bg-gray-700 transition flex-shrink-0" title="סיבוב (E)">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 11.667 0l3.181-3.183m-11.667-1.343a8.25 8.25 0 0 1-1.12-3.832 8.25 8.25 0 0 1 1.12-3.832 8.25 8.25 0 0 1 3.833-1.12 8.25 8.25 0 0 1 3.833 1.12 8.25 8.25 0 0 1 1.12 3.832 8.25 8.25 0 0 1-1.12 3.832 8.25 8.25 0 0 1-3.833 1.12 8.25 8.25 0 0 1-3.833-1.12Z" />
                </svg>
            </button>
            <button id="scale-btn" class="gizmo-btn p-3 text-white rounded-full hover:bg-gray-700 transition flex-shrink-0" title="גודל (R)">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8V5h3m12 0h3v3m0 11v3h-3m-12 0H3v-3"></path></svg>
            </button>

            <!-- קו הפרדה חדש -->
            <div class="border-l border-gray-600 h-10 my-auto mx-2 flex-shrink-0"></div>

            <!-- כפתורי קואליציה ואופוזיציה -->
            <button id="coalition-btn" class="px-4 py-2 text-white rounded-full bg-blue-600 hover:bg-blue-700 transition text-sm font-semibold flex-shrink-0" title="קואליציה">
                קואליציה
            </button>
            <button id="opposition-btn" class="px-4 py-2 text-white rounded-full bg-orange-600 hover:bg-orange-700 transition text-sm font-semibold flex-shrink-0" title="אופוזיציה">
                אופוזיציה
            </button>

            <!-- כפתור מחיקה -->
            <button id="delete-btn" class="p-3 text-white rounded-full hover:bg-red-600 transition flex-shrink-0" title="מחק (Delete)">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
            </button>
            <!-- רווח קטן בסוף במובייל לגלילה נוחה -->
            <div class="w-4 flex-shrink-0 md:hidden"></div>
        </div>
    </div>


    <!-- פאנלים צפים / מסך מלא -->
    <div id="scene-panel" class="fixed inset-0 z-40 bg-gray-900/95 backdrop-blur-sm hidden flex flex-col md:inset-auto md:z-auto md:top-20 md:right-5 md:w-72 md:max-w-xs md:rounded-lg md:shadow-xl md:bg-gray-900/80 md:backdrop-blur-sm">
        <div class="p-4 md:p-6 pb-4 flex justify-between items-center draggable-handle cursor-move sticky top-0 bg-gray-900/80 md:bg-transparent z-10">
            <h2 class="text-xl font-semibold text-white">בקרי סצנה</h2>
            <button class="p-1 text-gray-400 hover:text-white close-panel-btn">
                 <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="overflow-y-auto p-4 md:p-6 pt-0 hide-scrollbar mobile-panel-content flex-grow">
            <div class="space-y-3">
                <button id="save-scene-btn" class="w-full px-4 py-2 bg-green-600 hover:bg-green-700 rounded text-white transition-colors">שמור סצנה</button>
                <div>
                    <label for="load-scene-input" class="block text-sm font-medium text-gray-300 mb-1">טען סצנה (JSON)</label>
                    <input type="file" id="load-scene-input" class="texture-upload-input" accept=".json">
                </div>
            </div>
        </div>
    </div>

    <div id="lighting-panel" class="fixed inset-0 z-40 bg-gray-900/95 backdrop-blur-sm hidden flex flex-col md:inset-auto md:z-auto md:top-20 md:right-5 md:w-72 md:max-w-xs md:rounded-lg md:shadow-xl md:bg-gray-900/80 md:backdrop-blur-sm md:max-h-[80vh]">
        <div class="p-4 md:p-6 pb-4 flex justify-between items-center draggable-handle cursor-move sticky top-0 bg-gray-900/80 md:bg-transparent z-10">
            <h2 class="text-xl font-semibold text-white">בקרי תאורה</h2>
            <button class="p-1 text-gray-400 hover:text-white close-panel-btn">
                 <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="overflow-y-auto p-4 md:p-6 pt-0 hide-scrollbar mobile-panel-content flex-grow">
            <!-- רשימת מנורות -->
            <h3 class="text-lg font-medium text-gray-200 mb-2">מנורות בסצנה</h3>
            <div id="light-list" class="space-y-2 mb-4 max-h-40 overflow-y-auto hide-scrollbar">
                <div class="text-gray-400 text-sm">אין מנורות נקודתיות להצגה.</div>
            </div>
             <!-- כפתור הוספת מנורה -->
             <button id="add-point-light-btn" class="w-full px-4 py-2 mb-4 bg-blue-600 hover:bg-blue-700 rounded text-white transition-colors">הוסף מנורה נקודתית</button>
        </div>
    </div>

    <!-- [נמחק] פאנל אפקטים -->

    <div id="objects-panel" class="fixed inset-0 z-40 bg-gray-900/95 backdrop-blur-sm hidden flex flex-col md:inset-auto md:z-auto md:top-20 md:right-5 md:w-72 md:max-w-xs md:rounded-lg md:shadow-xl md:bg-gray-900/80 md:backdrop-blur-sm md:h-[70vh]">
         <div class="p-4 md:p-6 pb-4 flex justify-between items-center draggable-handle cursor-move sticky top-0 bg-gray-900/80 md:bg-transparent z-10">
            <h2 class="text-xl font-semibold text-white">אובייקטים בסצנה</h2>
            <button class="p-1 text-gray-400 hover:text-white close-panel-btn">
                 <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div id="object-list" class="space-y-4 overflow-y-auto p-4 md:p-6 pt-0 hide-scrollbar mobile-panel-content flex-grow">
            <!-- הרשימה תתמלא באופן דינמי על ידי JavaScript -->
            <div class="text-gray-400">טוען מודל...</div>
        </div>
    </div>

    <!-- פאנל אובייקט בודד (שמאל) -->
    <div id="single-object-panel" class="fixed inset-0 z-40 bg-gray-900/95 backdrop-blur-sm hidden flex flex-col md:inset-auto md:z-auto md:top-1/2 md:left-5 md:-translate-y-1/2 md:w-72 md:max-w-xs md:rounded-lg md:shadow-xl md:bg-gray-900/80 md:backdrop-blur-sm md:max-h-[80vh]">
        <div class="p-4 md:p-6 pb-2 flex justify-between items-center draggable-handle cursor-move sticky top-0 bg-gray-900/80 md:bg-transparent z-10">
             <h3 id="single-object-title-static" class="font-semibold text-lg text-white truncate">אובייקט</h3>
             <button id="close-single-panel-btn" class="p-1 text-gray-400 hover:text-white">
                 <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
             </button>
        </div>
        <div id="single-object-controls" class="overflow-y-auto p-4 md:p-6 pt-0 hide-scrollbar mobile-panel-content flex-grow">
            <!-- התוכן יוכנס לכאן דינמית -->
        </div>
    </div>

    <!-- פאנל מנורה נקודתית (שמאל) -->
    <div id="point-light-panel" class="fixed inset-0 z-40 bg-gray-900/95 backdrop-blur-sm hidden flex flex-col md:inset-auto md:z-auto md:top-1/2 md:left-5 md:-translate-y-1/2 md:w-72 md:max-w-xs md:rounded-lg md:shadow-xl md:bg-gray-900/80 md:backdrop-blur-sm md:max-h-[80vh]">
        <div class="p-4 md:p-6 pb-2 flex justify-between items-center draggable-handle cursor-move sticky top-0 bg-gray-900/80 md:bg-transparent z-10">
             <h3 id="point-light-title" class="font-semibold text-lg text-white truncate">מנורה נקודתית</h3>
             <button id="close-point-light-panel-btn" class="p-1 text-gray-400 hover:text-white">
                 <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
             </button>
        </div>
        <div id="point-light-controls" class="overflow-y-auto p-4 md:p-6 pt-0 space-y-4 hide-scrollbar mobile-panel-content flex-grow">
             <button
                class="duplicate-btn w-full px-3 py-1 text-sm bg-blue-600 hover:bg-blue-700 rounded text-white transition-colors"
                data-object-id=""> <!-- ID יתעדכן דינמית -->
                שכפל מנורה
             </button>
             <div>
                <label for="pl-intensity-slider" class="text-sm text-gray-300">עוצמה (<span id="pl-intensity-value">100</span>)</label>
                <input type="range" class="w-full point-light-control" id="pl-intensity-slider" min="0" max="150" step="1" value="100">
             </div>
             <div>
                <label for="pl-distance-slider" class="text-sm text-gray-300">טווח (<span id="pl-distance-value">100</span>)</label>
                <input type="range" class="w-full point-light-control" id="pl-distance-slider" min="0" max="100" step="0.5" value="100">
             </div>
             <div>
                <label for="pl-color-picker" class="text-sm text-gray-300">צבע</label>
                <input type="color" class="w-full h-10 p-1 bg-gray-700 border border-gray-600 rounded cursor-pointer point-light-control" id="pl-color-picker" value="#ffffff">
             </div>
             <hr class="border-gray-600">
             <div class="flex items-center space-x-2 space-x-reverse">
                 <input type="checkbox" class="point-light-control form-checkbox h-5 w-5 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500" id="pl-cast-shadow-checkbox">
                 <label for="pl-cast-shadow-checkbox" class="text-sm text-gray-300">הטל צל</label>
             </div>
             <div>
                 <!-- ערך התחלתי אמצעי -->
                <label for="pl-shadow-bias-slider" class="text-sm text-gray-300">היסט צל (Bias)</label>
                <input type="range" class="w-full point-light-control" id="pl-shadow-bias-slider" min="-0.01" max="0.01" step="0.0001" value="0">
             </div>
             <div>
                 <!-- ערך התחלתי אמצעי -->
                <label for="pl-shadow-normal-bias-slider" class="text-sm text-gray-300">היסט נורמל (Normal Bias)</label>
                <input type="range" class="w-full point-light-control" id="pl-shadow-normal-bias-slider" min="0" max="0.1" step="0.001" value="0.05">
             </div>
             <p class="text-gray-400 text-sm">הזז את המנורה באמצעות הגיזמו.</p>
        </div>
    </div>


    <!-- קונטיינר לסצנת ה-Three.js -->
    <div id="scene-container"></div>


    <!-- טעינת Three.js וספריות עזר -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "tween": "https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@23.1.2/dist/tween.esm.js",
                 "fflate": "https://cdn.jsdelivr.net/npm/fflate@0.8.1/esm/browser.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        // [נמחק] import { UnrealBloomPass }
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import * as TWEEN from 'tween';
        import { AnimationMixer } from 'three';

        let scene, camera, renderer, controls;
        let composer; // [נמחק] bloomPass
        let transformControls;
        let sceneObjects = [];
        let pointLights = [];
        let lightHelpersMap = new Map();
        let lightRangeIndicator = null;
        let knessetBounds = null;
        const boundsPadding = 2;

        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 20;
        let transformBeforeState = null;

        const MAX_SHADOW_CASTING_POINT_LIGHTS = 4;
        const KNESSET_MODEL_URL = 'https://raw.githubusercontent.com/orengamchi/kenesset_ai/main/kenesset_ai.glb';
        const CHAIR_MODEL_URL = 'https://raw.githubusercontent.com/orengamchi/kenesset_ai/main/seat_big.glb';

        const FBX_MODEL_URL = 'https://raw.githubusercontent.com/orengamchi/avatari/main/yair%20n.fbx';
        const AMSALEM_MODEL_URL = 'https://raw.githubusercontent.com/orengamchi/avatari/main/amsalem.fbx';
        const DERI_MODEL_URL = 'https://raw.githubusercontent.com/orengamchi/avatari/main/deri.fbx';
        const ANIMATION_URL = 'https://raw.githubusercontent.com/orengamchi/avatari/main/Sitting%20Clap.fbx';
        let sittingClapAnimation = null;
        let mixers = [];
        const clock = new THREE.Clock();


        const loadingManager = new THREE.LoadingManager();
        const textureLoader = new THREE.TextureLoader();
        const gltfLoader = new GLTFLoader(loadingManager);
        const fbxLoader = new FBXLoader(loadingManager);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let globalObjectCounter = 1;
        let selectedObjects = [];
        let areLightHelpersVisible = true;

        // DOM Elements
        const sceneContainer = document.getElementById('scene-container');
        const sidebarList = document.getElementById('object-list');
        const lightListContainer = document.getElementById('light-list');
        const saveBtn = document.getElementById('save-scene-btn');
        const loadInput = document.getElementById('load-scene-input');
        const addPointLightBtn = document.getElementById('add-point-light-btn');
        const sceneBtn = document.getElementById('scene-btn');
        const lightingBtn = document.getElementById('lighting-btn');
        // [נמחק] effectsBtn
        const toggleLightHelpersBtn = document.getElementById('toggle-light-helpers-btn');
        const objectsBtn = document.getElementById('objects-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const translateBtn = document.getElementById('translate-btn');
        const rotateBtn = document.getElementById('rotate-btn');
        const scaleBtn = document.getElementById('scale-btn');
        const gizmoButtons = [translateBtn, rotateBtn, scaleBtn];
        const deleteBtn = document.getElementById('delete-btn');
        const scenePanel = document.getElementById('scene-panel');
        const lightingPanel = document.getElementById('lighting-panel');
        // [נמחק] effectsPanel
        const objectsPanel = document.getElementById('objects-panel');
        const singleObjectPanel = document.getElementById('single-object-panel');
        const closeSinglePanelBtn = document.getElementById('close-single-panel-btn');
        const pointLightPanel = document.getElementById('point-light-panel');
        const closePointLightPanelBtn = document.getElementById('close-point-light-panel-btn');
        const plIntensitySlider = document.getElementById('pl-intensity-slider');
        const plDistanceSlider = document.getElementById('pl-distance-slider');
        const plIntensityValueSpan = document.getElementById('pl-intensity-value');
        const plDistanceValueSpan = document.getElementById('pl-distance-value');
        const plColorPicker = document.getElementById('pl-color-picker');
        const plCastShadowCheckbox = document.getElementById('pl-cast-shadow-checkbox');
        const plShadowBiasSlider = document.getElementById('pl-shadow-bias-slider');
        const plShadowNormalBiasSlider = document.getElementById('pl-shadow-normal-bias-slider');
        const coalitionBtn = document.getElementById('coalition-btn');
        // [נמחק] bloom sliders
        const allPanels = [scenePanel, lightingPanel, objectsPanel, singleObjectPanel, pointLightPanel]; // [נמחק] effectsPanel מהרשימה

        // --- Initialization ---
        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // רקע שחור

            camera = new THREE.PerspectiveCamera(75, sceneContainer.clientWidth / sceneContainer.clientHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.toneMapping = THREE.ReinhardToneMapping;
            sceneContainer.appendChild(renderer.domElement);

            // יצירת 8 מנורות התחלתיות - Bias אמצעי
            createPointLight(new THREE.Vector3(5, 15, 5), 100, 100, 0xffffff, true, 0, 0.05); // מנורה 1 עם צל
            createPointLight(new THREE.Vector3(-5, 15, 5), 100, 100, 0xffffff, true, 0, 0.05); // מנורה 2 עם צל
            createPointLight(new THREE.Vector3(5, 15, -5), 100, 100, 0xffffff, false, 0, 0.05); // מנורה 3 ללא צל
            createPointLight(new THREE.Vector3(-5, 15, -5), 100, 100, 0xffffff, false, 0, 0.05); // מנורה 4 ללא צל
            // הוספת 4 מנורות נוספות
            createPointLight(new THREE.Vector3(10, 15, 10), 100, 100, 0xffffff, false, 0, 0.05); // מנורה 5 ללא צל
            createPointLight(new THREE.Vector3(-10, 15, 10), 100, 100, 0xffffff, false, 0, 0.05); // מנורה 6 ללא צל
            createPointLight(new THREE.Vector3(10, 15, -10), 100, 100, 0xffffff, false, 0, 0.05); // מנורה 7 ללא צל
            createPointLight(new THREE.Vector3(-10, 15, -10), 100, 100, 0xffffff, false, 0, 0.05); // מנורה 8 ללא צל


            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 2, 0);
            controls.maxPolarAngle = Math.PI / 2.05;

            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', (event) => {
                controls.enabled = !event.value;
                if (event.value) {
                    if (transformControls.object) {
                        transformBeforeState = { position: transformControls.object.position.clone(), rotation: transformControls.object.rotation.clone(), scale: transformControls.object.scale.clone() };
                    }
                } else if (transformBeforeState && transformControls.object) {
                    addHistory({ type: 'transform', object: transformControls.object, before: transformBeforeState, after: { position: transformControls.object.position.clone(), rotation: transformControls.object.rotation.clone(), scale: transformControls.object.scale.clone() } });
                    transformBeforeState = null;
                }
            });
            transformControls.addEventListener('objectChange', () => {
                if (transformControls.object) {
                    const actualLight = lightHelpersMap.get(transformControls.object);
                    if (actualLight) {
                        actualLight.position.copy(transformControls.object.position);
                        if (actualLight instanceof THREE.PointLight) updateRangeIndicator();
                    }
                    const parentModel = transformControls.object;
                    if (parentModel && parentModel.userData.transform) {
                         parentModel.userData.transform.position.copy(parentModel.position);
                         parentModel.userData.transform.rotation.copy(parentModel.rotation);
                         parentModel.userData.transform.scale.copy(parentModel.scale);
                    }
                }
            });
            scene.add(transformControls);

            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera); composer.addPass(renderPass);
            // [נמחק] bloomPass
            const outputPass = new OutputPass(); composer.addPass(outputPass);

            loadAllModels();

            window.addEventListener('resize', onWindowResize);

            // --- Event Listeners ---
            sidebarList.addEventListener('click', onSidebarClick);
            lightListContainer.addEventListener('click', onLightListClick);
            addPointLightBtn.addEventListener('click', handleAddPointLight);

            sceneContainer.addEventListener('click', (e) => {
                 const isClickOnGizmo = transformControls.dragging;
                 const isClickOnCanvas = e.target === renderer.domElement;

                 if (isClickOnCanvas && !isClickOnGizmo) {
                     const rect = renderer.domElement.getBoundingClientRect();
                     mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                     mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                     raycaster.setFromCamera(mouse, camera);
                     const intersects = raycaster.intersectObjects(sceneObjects.map(o => o.mesh), false);

                     if (intersects.length > 0) {
                         let intersectedSceneObject = null;
                         for (const intersect of intersects) {
                             intersectedSceneObject = sceneObjects.find(obj => obj.mesh === intersect.object);
                             if (intersectedSceneObject) break;
                         }
                         if (intersectedSceneObject) {
                             selectObject(intersectedSceneObject, e);
                         }
                     } else if (!(e.ctrlKey || e.metaKey)) {
                         deselectObject();
                         closeSinglePanels();
                     }
                 }
            });
             sceneContainer.addEventListener('dblclick', onDoubleClick);

            saveBtn.addEventListener('click', saveScene);
            loadInput.addEventListener('change', loadScene);
            sceneBtn.addEventListener('click', (e) => { e.stopPropagation(); openPanel(scenePanel); });
            lightingBtn.addEventListener('click', (e) => { e.stopPropagation(); openPanel(lightingPanel); });
            // [נמחק] effectsBtn listener
            objectsBtn.addEventListener('click', (e) => { e.stopPropagation(); openPanel(objectsPanel); });
            toggleLightHelpersBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleLightHelpers(); });
            coalitionBtn.addEventListener('click', (e) => { e.stopPropagation(); loadCoalitionModels(); });

            document.querySelectorAll('.close-panel-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const panel = e.target.closest('.fixed');
                    if (panel) panel.classList.add('hidden');
                });
            });
            undoBtn.addEventListener('click', (e) => { e.stopPropagation(); undo(); });
            redoBtn.addEventListener('click', (e) => { e.stopPropagation(); redo(); });
            deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteSelected(); });
            translateBtn.addEventListener('click', (e) => { e.stopPropagation(); setGizmoMode('translate'); });
            rotateBtn.addEventListener('click', (e) => { e.stopPropagation(); setGizmoMode('rotate'); });
            scaleBtn.addEventListener('click', (e) => { e.stopPropagation(); setGizmoMode('scale'); });
            closeSinglePanelBtn.addEventListener('click', (e) => { e.stopPropagation(); singleObjectPanel.classList.add('hidden'); });
            closePointLightPanelBtn.addEventListener('click', (e) => { e.stopPropagation(); pointLightPanel.classList.add('hidden'); });
            singleObjectPanel.addEventListener('click', onSinglePanelClick);
            singleObjectPanel.addEventListener('change', onSinglePanelChange);
            singleObjectPanel.addEventListener('input', onSinglePanelChange);
            pointLightPanel.addEventListener('click', onPointLightPanelClick);
            pointLightPanel.addEventListener('input', onPointLightPanelChange);
            pointLightPanel.addEventListener('change', onPointLightPanelChange);
            // [נמחק] bloom slider listeners

            makeDraggable(scenePanel);
            makeDraggable(lightingPanel);
            // [נמחק] makeDraggable(effectsPanel);
            makeDraggable(objectsPanel);
            makeDraggable(singleObjectPanel);
            makeDraggable(pointLightPanel);

            allPanels.forEach(panel => { panel.addEventListener('click', (e) => e.stopPropagation()); });
            window.addEventListener('keydown', onKeyDown);
            updateHistoryButtons();
            toggleLightHelpersBtn.classList.toggle('active', areLightHelpersVisible);
        }

        // --- Light Creation ---
        // ערכי ברירת מחדל של bias הם אמצע הטווח
        function createPointLight(position, intensity, distance = 100, color = 0xffffff, castShadow = false, shadowBias = 0, shadowNormalBias = 0.05) {
             const currentShadowCasters = pointLights.filter(pl => pl.light.castShadow).length;
             let actualCastShadow = castShadow;
             if (castShadow && currentShadowCasters >= MAX_SHADOW_CASTING_POINT_LIGHTS) {
                 actualCastShadow = false;
                 // אל תציג אזהרה עבור מנורות התחלתיות שנוספו מעבר למגבלה
                 // console.warn(`מגבלת מנורות מטילות צל (${MAX_SHADOW_CASTING_POINT_LIGHTS}) הושגה. המנורה החדשה לא תטיל צל.`);
             }

            const pointLight = new THREE.PointLight(color, intensity, distance);
            pointLight.position.copy(position);
            pointLight.castShadow = actualCastShadow;
            pointLight.shadow.bias = shadowBias;
            pointLight.shadow.normalBias = shadowNormalBias;
            pointLight.shadow.mapSize.width = 512; pointLight.shadow.mapSize.height = 512;
            pointLight.shadow.camera.near = 0.5; pointLight.shadow.camera.far = 50;
            scene.add(pointLight);

            const helperGeo = new THREE.SphereGeometry(0.3, 16, 8);
            const helperMat = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
            const helperMesh = new THREE.Mesh(helperGeo, helperMat);
            const lightIndex = pointLights.length + 1;
            helperMesh.name = `PointLight Helper ${lightIndex}`;
            helperMesh.position.copy(pointLight.position);
            helperMesh.visible = areLightHelpersVisible;
            scene.add(helperMesh);

            lightHelpersMap.set(helperMesh, pointLight);
            helperMesh.userData.transform = { position: helperMesh.position.clone(), rotation: helperMesh.rotation.clone(), scale: helperMesh.scale.clone() };

            const sceneObjectData = { id: helperMesh.uuid, stableId: helperMesh.uuid, name: `מנורה נקודתית ${lightIndex}`, mesh: helperMesh, originalMaterial: helperMat.clone(), parentModel: helperMesh, isLightHelper: true, lightType: 'point' };
            sceneObjects.push(sceneObjectData);
            pointLights.push({ light: pointLight, helper: helperMesh, data: sceneObjectData });

            populateLightList();
            return { light: pointLight, helper: helperMesh, data: sceneObjectData };
        }

        function handleAddPointLight() {
             const position = new THREE.Vector3(Math.random() * 10 - 5, 5, Math.random() * 10 - 5);
             // Bias אמצעי
             const { light, helper, data } = createPointLight(position, 100, 100, 0xffffff, false, 0, 0.05);
             addHistory({ type: 'addLight', lightType: 'point', addedLight: light, addedHelper: helper, addedSceneObjectData: data });
        }

        // [נמחק] onBloomChange

        async function loadAnimation(url) {
            return new Promise((resolve, reject) => {
                fbxLoader.load(url, (object) => {
                    if (object.animations && object.animations.length > 0) {
                        resolve(object.animations[0]);
                    } else {
                        reject(new Error(`No animations found in ${url}`));
                    }
                }, undefined, (error) => {
                    reject(error);
                });
            });
        }

        // --- Model Loading ---
        function getModelNameLogic(url) {

             if (url.toLowerCase().endsWith('.fbx')) {
                 if (url.includes('yair')) return () => "מודל יאיר";
                 if (url.includes('amsalem')) return () => "מודל אמסלם";
                 if (url.includes('deri')) return () => "מודל דרעי";
                 return () => "מודל FBX";
             }
            if (url === CHAIR_MODEL_URL) {
                return (objectName, material) => { const matName = Array.isArray(material) ? (material[0] ? material[0].name : objectName) : (material.name || objectName); if (matName === 'kneset_chair_Color_C') return 'ריפוד כיסא מנהלים'; if (matName === 'wheels') return 'גלגלי כיסא מנהלים'; if (matName === 'chair_low_seat_BaseColor') return 'מושב כיסא מנהלים'; if (Array.isArray(material)) { const names = material.map(m => m.name).filter(Boolean); if (names.includes('kneset_chair_Color_C') && names.includes('wheels')) return 'כיסא מנהלים (גוף וגלגלים)'; } return null; };
            }
             if (url === KNESSET_MODEL_URL) {
                 // זיהוי הפאנלים האדומים גם כאן
                 return (objectName, material) => {
                     const matName = Array.isArray(material) ? (material[0] ? material[0].name : objectName) : (material.name || objectName);
                     if (matName && matName.toLowerCase().includes('mat_primitive1')) {
                         return 'פאנל LED';
                     }
                     return "מודל הכנסת";
                 };
             }
            return () => null;
        }

        async function loadCoalitionModels() {
            console.log('טוען מודלים של קואליציה...');
            coalitionBtn.disabled = true;
            coalitionBtn.textContent = 'טוען...';

            try {
                if (!sittingClapAnimation) {
                    console.log('טוען אנימציה...');
                    sittingClapAnimation = await loadAnimation(ANIMATION_URL);
                    console.log('אנימציה נטענה.');
                }

                const modelsToLoad = [
                    { url: FBX_MODEL_URL, options: { scale: new THREE.Vector3(0.01, 0.01, 0.01), position: new THREE.Vector3(-3, 0, -3), nameLogic: getModelNameLogic(FBX_MODEL_URL), isLocked: false } },
                    { url: AMSALEM_MODEL_URL, options: { scale: new THREE.Vector3(0.01, 0.01, 0.01), position: new THREE.Vector3(-1, 0, -3), nameLogic: getModelNameLogic(AMSALEM_MODEL_URL), isLocked: false } },
                    { url: DERI_MODEL_URL, options: { scale: new THREE.Vector3(0.01, 0.01, 0.01), position: new THREE.Vector3(1, 0, -3), nameLogic: getModelNameLogic(DERI_MODEL_URL), isLocked: false } }
                ];

                for (const modelData of modelsToLoad) {
                    const newModel = await loadFBXModel(modelData.url, modelData.options);

                    if (sittingClapAnimation) {
                        playAnimationOnModel(newModel, sittingClapAnimation);
                    }
                }
                console.log('מודלים של קואליציה נטענו והאנימציה הופעלה.');
                populateSidebar();
            } catch (error) {
                console.error('שגיאה בטעינת מודלים של קואליציה או אנימציה:', error);
            } finally {
                coalitionBtn.disabled = false;
                coalitionBtn.textContent = 'קואליציה';
            }
        }

        function playAnimationOnModel(model, animationClip) {
            const mixer = new AnimationMixer(model);
            const action = mixer.clipAction(animationClip);
            action.play();
            mixers.push(mixer);
            model.userData.mixer = mixer;
        }

        async function loadAllModels(modelsToLoad = null) {
            mixers = []; // נקה את המיקסרים הקיימים

            const modelsToRemove = sceneObjects.filter(obj => obj.parentModel && !obj.isLightHelper).map(obj => obj.parentModel);
            const uniqueModelsToRemove = [...new Set(modelsToRemove)];
            uniqueModelsToRemove.forEach(model => scene.remove(model));
            sceneObjects = sceneObjects.filter(obj => obj.isLightHelper);
            deselectObject();
            closeSinglePanels();
            knessetBounds = null;

            let modelList;
            if (modelsToLoad) {
                modelList = modelsToLoad.map(modelData => ({
                    url: modelData.url,
                    options: {
                        scale: new THREE.Vector3().fromArray(modelData.transform.scale),
                        position: new THREE.Vector3().fromArray(modelData.transform.position),
                        rotation: new THREE.Euler().fromArray(modelData.transform.rotation),
                        nameLogic: getModelNameLogic(modelData.url),
                        isLocked: modelData.url === KNESSET_MODEL_URL
                    },
                    materials: modelData.materials,
                    hasAnimation: modelData.hasAnimation
                }));
            } else {
                sidebarList.innerHTML = `<div class="text-gray-400">טוען מודלים...</div>`;
                modelList = [
                     { url: KNESSET_MODEL_URL, options: { scale: new THREE.Vector3(0.5, 0.5, 0.5), position: new THREE.Vector3(0, 0, 0), nameLogic: getModelNameLogic(KNESSET_MODEL_URL), isLocked: true }, materials: null, hasAnimation: false },
                    { url: CHAIR_MODEL_URL, options: { scale: new THREE.Vector3(3, 3, 3), position: new THREE.Vector3(0, 0, 0), nameLogic: getModelNameLogic(CHAIR_MODEL_URL), isLocked: false }, materials: null, hasAnimation: false }
                ];
            }
            try {
                 let animationClip = null;
                 if (modelList.some(m => m.hasAnimation)) {
                     try {
                         animationClip = await loadAnimation(ANIMATION_URL);
                         sittingClapAnimation = animationClip;
                     } catch (animError) {
                         console.error("Failed to load animation:", animError);
                     }
                 }

                for (const modelData of modelList) {
                     let newModel;
                     if (modelData.url.toLowerCase().endsWith('.glb') || modelData.url.toLowerCase().endsWith('.gltf')) {
                         newModel = await loadGLBModel(modelData.url, modelData.options);
                     } else if (modelData.url.toLowerCase().endsWith('.fbx')) {
                         newModel = await loadFBXModel(modelData.url, modelData.options);
                     } else {
                         console.warn(`Unsupported model format: ${modelData.url}`);
                         continue;
                     }

                    if (modelData.options.rotation) { newModel.rotation.copy(modelData.options.rotation); if (newModel.userData.transform) { newModel.userData.transform.rotation.copy(newModel.rotation); } }
                     if (modelData.url === KNESSET_MODEL_URL) {
                         knessetBounds = new THREE.Box3().setFromObject(newModel);
                         console.log("Knesset Bounds Calculated:", knessetBounds);
                     }
                    if (modelData.materials) {
                        for (const stableId in modelData.materials) {
                             const matProps = modelData.materials[stableId];
                             const targetObject = sceneObjects.find(obj => obj.stableId === stableId && obj.parentModel === newModel);
                             if (targetObject) {
                                 const materialToChange = getMaterialToChange(targetObject.mesh);
                                 const applyLoadedProps = (mat) => {
                                     if (!matProps.textureDataUrl && matProps.color) {
                                         mat.color.set(matProps.color.startsWith('#') ? matProps.color : "#" + matProps.color);
                                     } else {
                                         mat.color.set(0xffffff);
                                     }
                                     if (matProps.roughness !== undefined) mat.roughness = matProps.roughness;
                                     if (matProps.metalness !== undefined) mat.metalness = matProps.metalness;
                                     if (matProps.opacity !== undefined) {
                                         mat.opacity = matProps.opacity;
                                         mat.transparent = matProps.opacity < 1;
                                     }
                                     if (matProps.emissiveIntensity !== undefined) {
                                        mat.emissiveIntensity = matProps.emissiveIntensity;
                                        if(targetObject.name === 'פאנל LED' && mat.emissiveIntensity > 0 && mat.emissive.getHexString() === '000000') {
                                            mat.emissive.setHex(0xFF0000);
                                        }
                                     }
                                     mat.aoMap = null;
                                     mat.needsUpdate = true;
                                 };
                                 if (Array.isArray(materialToChange)) {
                                     materialToChange.forEach(applyLoadedProps);
                                 } else if(materialToChange) {
                                     applyLoadedProps(materialToChange);
                                 }
                                 if (matProps.textureDataUrl) {
                                     await applyTextureFromDataUrl(targetObject, matProps.textureDataUrl, false);
                                 }
                                 if (matProps.bumpDataUrl) {
                                     await applyBumpMapFromDataUrl(targetObject, matProps.bumpDataUrl, false);
                                 }
                             }
                         }
                     }
                      if (modelData.hasAnimation && animationClip) {
                          playAnimationOnModel(newModel, animationClip);
                      }
                }
                console.log("All models loaded successfully.");
                populateSidebar();
            } catch (error) {
                console.error("Failed to load one or more models:", error);
                sidebarList.innerHTML = `<div class="text-red-400">שגיאה בטעינת מודלים.</div>`;
            }
        }

        function loadGLBModel(url, options) {
             return new Promise((resolve, reject) => {
                 gltfLoader.load(url, (gltf) => {
                     const model = gltf.scene;
                     model.userData.url = url;
                     model.userData.initialOptions = options;
                     model.userData.transform = { position: (options.position || new THREE.Vector3()).clone(), rotation: (options.rotation || new THREE.Euler()).clone(), scale: (options.scale || new THREE.Vector3(1,1,1)).clone() };
                     model.scale.copy(model.userData.transform.scale);
                     model.position.copy(model.userData.transform.position);
                     model.rotation.copy(model.userData.transform.rotation);
                     model.userData.isLocked = options.isLocked || false;

                     model.traverse((child) => {
                         if (child.isMesh) {
                             child.castShadow = true; child.receiveShadow = true;
                             child.userData.stableId = child.uuid;
                             child.userData.isLocked = model.userData.isLocked;

                             const originalMaterial = Array.isArray(child.material) ? child.material.map(m => m.clone()) : child.material.clone();
                             let newMaterial, objectName = child.name;
                             const processMaterial = (mat) => {
                                 const matClone = mat.clone();
                                 matClone.userData = {};
                                 matClone.aoMap = null;
                                 matClone.transparent = matClone.opacity < 1;

                                 // זיהוי והארת הפאנלים האדומים
                                 if (url === KNESSET_MODEL_URL && mat.name && mat.name.toLowerCase().includes('mat_primitive1')) {
                                     console.log('Found potential panel material:', mat.name);
                                     matClone.emissive.setHex(0xFF0000); // צבע פליטה אדום
                                     matClone.emissiveIntensity = 1.5; // עוצמת פליטה
                                     matClone.color.setHex(0x330000); // צבע בסיס כהה יותר
                                 }
                                 return matClone;
                             };
                             if (Array.isArray(child.material)) { newMaterial = child.material.map(processMaterial); child.material = newMaterial; const materialNames = child.material.map(m => m.name).filter(Boolean); if (materialNames.length > 0) objectName = materialNames.join(' / '); } else if (child.material) { newMaterial = processMaterial(child.material); child.material = newMaterial; if (newMaterial.name && newMaterial.name !== 'default') objectName = newMaterial.name; } else { newMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd }); newMaterial.userData = {}; child.material = newMaterial; }

                             if (options.nameLogic) {
                                 let specificName = options.nameLogic(objectName, newMaterial);
                                 if (!specificName && (!objectName || objectName.startsWith('Mesh') || objectName.startsWith('pasted_') || objectName.startsWith('Group'))) {
                                     objectName = `חלק_${globalObjectCounter++}`;
                                 } else if (specificName) {
                                     objectName = specificName;
                                 }
                             } else if (!objectName || objectName.startsWith('Mesh') || objectName.startsWith('pasted_') || objectName.startsWith('Group')) {
                                objectName = `חלק_${globalObjectCounter++}`;
                             }


                             sceneObjects.push({ id: child.uuid, stableId: child.userData.stableId, name: objectName, mesh: child, originalMaterial: originalMaterial, parentModel: model });
                         }
                     });
                     scene.add(model);
                     resolve(model);
                 }, (xhr) => { if (sidebarList.innerHTML.includes('טוען')) { sidebarList.innerHTML = `<div class="text-gray-400">טוען: ${url.split('/').pop()}... ${Math.round(xhr.loaded / xhr.total * 100)}%</div>`; } }, (error) => { console.error(`Error loading ${url}:`, error); reject(error); });
             });
        }

         function loadFBXModel(url, options) {
             return new Promise((resolve, reject) => {
                 fbxLoader.load(url, (object) => {
                     const model = object;
                     model.userData.url = url;
                     model.userData.initialOptions = options;
                     model.userData.transform = { position: (options.position || new THREE.Vector3()).clone(), rotation: (options.rotation || new THREE.Euler()).clone(), scale: (options.scale || new THREE.Vector3(1,1,1)).clone() };
                     model.scale.copy(model.userData.transform.scale);
                     model.position.copy(model.userData.transform.position);
                     model.rotation.copy(model.userData.transform.rotation);
                     model.userData.isLocked = options.isLocked || false;

                     model.traverse((child) => {
                         if (child.isMesh) {
                             child.castShadow = true;
                             child.receiveShadow = true;
                             child.userData.stableId = child.uuid;
                             child.userData.isLocked = model.userData.isLocked;

                             const originalMaterial = Array.isArray(child.material) ? child.material.map(m => m.clone()) : child.material.clone();
                             let newMaterial, objectName = child.name;

                             const processMaterial = (mat) => {
                                 const standardMat = new THREE.MeshStandardMaterial({
                                     color: mat.color || 0xdddddd,
                                     map: mat.map || null,
                                     roughness: mat.roughness !== undefined ? mat.roughness : 0.8,
                                     metalness: mat.metalness !== undefined ? mat.metalness : 0.1,
                                     opacity: mat.opacity !== undefined ? mat.opacity : 1,
                                     transparent: (mat.opacity !== undefined && mat.opacity < 1) || mat.transparent || false
                                 });
                                 standardMat.userData = {};
                                 return standardMat;
                             };

                             if (Array.isArray(child.material)) {
                                 newMaterial = child.material.map(processMaterial);
                                 child.material = newMaterial;
                                 const materialNames = child.material.map(m => m.name).filter(Boolean);
                                 if (materialNames.length > 0) objectName = materialNames.join(' / ');
                             } else if (child.material) {
                                 newMaterial = processMaterial(child.material);
                                 child.material = newMaterial;
                                 if (newMaterial.name && newMaterial.name !== 'default') objectName = newMaterial.name;
                             } else {
                                 newMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd });
                                 newMaterial.userData = {};
                                 child.material = newMaterial;
                             }


                             if (options.nameLogic) {
                                 const specificName = options.nameLogic(objectName, newMaterial);
                                 if (specificName) objectName = specificName;
                             }
                              if (!objectName || objectName.startsWith('Mesh') || objectName.startsWith('Group')) { objectName = `חלק FBX_${globalObjectCounter++}`; }


                             sceneObjects.push({ id: child.uuid, stableId: child.userData.stableId, name: objectName, mesh: child, originalMaterial: originalMaterial, parentModel: model });
                         }
                     });
                     scene.add(model);
                     resolve(model);
                 }, (xhr) => {
                     if (sidebarList.innerHTML.includes('טוען')) { sidebarList.innerHTML = `<div class="text-gray-400">טוען: ${url.split('/').pop()}... ${Math.round(xhr.loaded / xhr.total * 100)}%</div>`; }
                 }, (error) => {
                     console.error(`Error loading ${url}:`, error);
                     reject(error);
                 });
             });
         }


        // --- UI Population ---
        function populateSidebar() { sidebarList.innerHTML = ''; const objectsToList = sceneObjects.filter(obj => !obj.isLightHelper); if (objectsToList.length === 0) { sidebarList.innerHTML = '<div class="text-gray-400 text-sm">אין אובייקטים להצגה.</div>'; return; } objectsToList.forEach(obj => { const objElement = document.createElement('div'); objElement.id = `sidebar-item-${obj.id}`; objElement.className = 'p-3 bg-gray-700 rounded-lg shadow cursor-pointer hover:bg-gray-600 object-item'; objElement.dataset.objectId = obj.id; objElement.innerHTML = ` <h3 class="font-semibold text-lg text-white pointer-events-none">${obj.name}</h3> <p class="text-sm text-gray-400 pointer-events-none">ID: ...${obj.id.slice(-6)}</p> `; if (selectedObjects.includes(obj)) { objElement.classList.add('selected-object'); } sidebarList.appendChild(objElement); }); }
        function populateLightList() { lightListContainer.innerHTML = ''; const lightsToList = sceneObjects.filter(obj => obj.isLightHelper && obj.lightType === 'point'); if (lightsToList.length === 0) { lightListContainer.innerHTML = '<div class="text-gray-400 text-sm">אין מנורות נקודתיות להצגה.</div>'; return; } lightsToList.forEach(obj => { const lightElement = document.createElement('div'); lightElement.id = `light-item-${obj.id}`; lightElement.className = 'p-3 bg-gray-600 rounded-lg shadow cursor-pointer hover:bg-gray-500 light-item'; lightElement.dataset.objectId = obj.id; lightElement.innerHTML = ` <h3 class="font-semibold text-base text-white pointer-events-none">${obj.name.replace(' (Helper)', '')}</h3> <p class="text-xs text-gray-300 pointer-events-none">ID: ...${obj.id.slice(-6)}</p> `; if (selectedObjects.includes(obj)) { lightElement.classList.add('selected-object'); } lightListContainer.appendChild(lightElement); }); }

        // --- Panel Management ---
         function openPanel(panelToOpen) {
            const isOpening = panelToOpen.classList.contains('hidden');
            const isSecondaryPanel = panelToOpen === singleObjectPanel || panelToOpen === pointLightPanel;

            // Hide all main panels first, except the one being opened/closed
            allPanels.forEach(p => {
                 if (p !== panelToOpen && (p !== singleObjectPanel && p !== pointLightPanel)) {
                     p.classList.add('hidden');
                 }
            });
             // Close secondary panels if opening a main panel
             if (!isSecondaryPanel) {
                 closeSinglePanels();
             }

            // Toggle the target panel
            panelToOpen.classList.toggle('hidden');

            // Reset position only when opening (going from hidden to visible) on desktop
            if (!isOpening && window.innerWidth >= 768 && (!panelToOpen.style.left || !panelToOpen.style.top) ) {
                const topBarHeight = document.getElementById('top-menu-bar-wrapper')?.offsetHeight || 60;
                if (isSecondaryPanel) {
                    panelToOpen.style.left = '1.25rem';
                    panelToOpen.style.right = 'auto';
                    panelToOpen.style.transform = 'translateY(-50%)';
                    panelToOpen.style.top = '50%';
                } else {
                    panelToOpen.style.right = '1.25rem';
                    panelToOpen.style.left = 'auto';
                    panelToOpen.style.transform = '';
                    panelToOpen.style.top = `${topBarHeight + 20}px`;
                }
            }
        }

        function closeSinglePanels() { singleObjectPanel.classList.add('hidden'); pointLightPanel.classList.add('hidden'); }

        // --- UI Interaction Handlers ---
        function onSidebarClick(event) { const item = event.target.closest('.object-item'); if (!item) return; const objectId = item.dataset.objectId; const targetObject = sceneObjects.find(obj => obj.id === objectId); if (targetObject) { selectObject(targetObject, event); zoomToSelected(); } }
        function onLightListClick(event) { const item = event.target.closest('.light-item'); if (!item) return; const objectId = item.dataset.objectId; const targetObject = sceneObjects.find(obj => obj.id === objectId); if (targetObject) { selectObject(targetObject, event); zoomToSelected(); } }

        function onSinglePanelClick(event) {
            event.stopPropagation();
            const objectId = event.target.dataset.objectId;
            if (!objectId) return;
            const targetObject = sceneObjects.find(obj => obj.id === objectId);
            if (!targetObject) return;

            if (event.target.classList.contains('revert-btn')) {
                if (selectedObjects.includes(targetObject)) {
                    revertToDefault(targetObject);
                    showSingleObjectPanel(targetObject);
                }
            } else if (event.target.classList.contains('duplicate-btn')) {
                if (!targetObject.isLightHelper && targetObject.mesh.userData.isLocked) {
                    console.warn("Cannot duplicate locked model.");
                    return;
                }
                if (targetObject.isLightHelper) {
                   if (selectedObjects.includes(targetObject)) duplicateLight(targetObject);
                } else {
                   duplicateModel(objectId);
                }
            } else if (event.target.classList.contains('chair-camera-btn')) {
                 if (selectedObjects.includes(targetObject)) {
                     focusCameraOnChair(targetObject);
                 }
             }
        }
        function onSinglePanelChange(event) {
            event.stopPropagation();
            const objectId = event.target.dataset.objectId;
            if (!objectId) return;
            const targetObject = selectedObjects.length > 0 ? selectedObjects.find(obj => obj.id === objectId) : null;
            if (!targetObject) return;

            // Texture/Bump Upload
            if (event.target.classList.contains('texture-upload-input')) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (e) => await applyTextureFromDataUrl(targetObject, e.target.result);
                reader.readAsDataURL(file);
                event.target.value = null;
                return;
            }
            if (event.target.classList.contains('bump-upload-input')) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (e) => await applyBumpMapFromDataUrl(targetObject, e.target.result);
                reader.readAsDataURL(file);
                event.target.value = null;
                return;
            }

            // Material Property Change
            const materialToChange = getMaterialToChange(targetObject.mesh);
            if (!materialToChange) return;

            let propertyName = null, newValue = null, beforeValue = null;
            const firstMat = Array.isArray(materialToChange) ? materialToChange[0] : materialToChange;

            if (event.target.classList.contains('color-picker')) {
                propertyName = 'color';
                newValue = event.target.value;
                beforeValue = '#' + firstMat.color.getHexString();
            } else if (event.target.classList.contains('roughness-slider')) {
                propertyName = 'roughness';
                newValue = parseFloat(event.target.value);
                beforeValue = firstMat.roughness;
            } else if (event.target.classList.contains('metalness-slider')) {
                propertyName = 'metalness';
                newValue = parseFloat(event.target.value);
                beforeValue = firstMat.metalness;
            } else if (event.target.classList.contains('opacity-slider')) {
                propertyName = 'opacity';
                newValue = parseFloat(event.target.value);
                beforeValue = firstMat.opacity;
            } else if (event.target.classList.contains('emissive-intensity-slider')) {
                propertyName = 'emissiveIntensity';
                newValue = parseFloat(event.target.value);
                beforeValue = firstMat.emissiveIntensity;
            }

            // Add history only on final change (e.g., mouseup on slider)
            if (propertyName && newValue !== beforeValue && event.type === 'change') {
                addHistory({ type: 'material', mesh: targetObject.mesh, property: propertyName, before: beforeValue, after: newValue });
            }

            // Apply change to material(s)
            const applyToMaterial = (mat) => {
                if (event.target.classList.contains('color-picker')) {
                    mat.color.set(event.target.value);
                    mat.map = null; // Remove texture if color is set
                    mat.userData.textureDataUrl = null;
                }
                if (event.target.classList.contains('roughness-slider')) mat.roughness = parseFloat(event.target.value);
                if (event.target.classList.contains('metalness-slider')) mat.metalness = parseFloat(event.target.value);
                if (event.target.classList.contains('opacity-slider')) {
                    mat.opacity = parseFloat(event.target.value);
                    mat.transparent = mat.opacity < 1; // Enable transparency if opacity < 1
                }
                if (event.target.classList.contains('emissive-intensity-slider')) {
                     mat.emissiveIntensity = parseFloat(event.target.value);
                 }
                mat.needsUpdate = true;
            };

            if (Array.isArray(materialToChange)) materialToChange.forEach(applyToMaterial);
            else applyToMaterial(materialToChange);
        }
        function onPointLightPanelClick(event) { event.stopPropagation(); if (event.target.classList.contains('duplicate-btn')) { const lastSelected = selectedObjects.length > 0 ? selectedObjects[selectedObjects.length - 1] : null; if (lastSelected && lastSelected.isLightHelper) { duplicateLight(lastSelected); } } }
        function onPointLightPanelChange(event) { const lastSelected = selectedObjects.length > 0 ? selectedObjects[selectedObjects.length - 1] : null; if (!lastSelected || !lastSelected.isLightHelper || lastSelected.lightType !== 'point') return; const light = lightHelpersMap.get(lastSelected.mesh); if (!light) return; const target = event.target; let property, value, beforeValue; let isShadowProperty = false; if (target.id === 'pl-intensity-slider') { property = 'intensity'; value = parseFloat(target.value); beforeValue = light.intensity; plIntensityValueSpan.textContent = value.toFixed(1); } else if (target.id === 'pl-distance-slider') { property = 'distance'; value = parseFloat(target.value); beforeValue = light.distance; plDistanceValueSpan.textContent = value.toFixed(1); } else if (target.id === 'pl-color-picker') { property = 'color'; value = target.value; beforeValue = '#' + light.color.getHexString(); } else if (target.id === 'pl-cast-shadow-checkbox') { property = 'castShadow'; value = target.checked; beforeValue = light.castShadow; isShadowProperty = true; } else if (target.id === 'pl-shadow-bias-slider') { property = 'bias'; value = parseFloat(target.value); beforeValue = light.shadow.bias; isShadowProperty = true; } else if (target.id === 'pl-shadow-normal-bias-slider') { property = 'normalBias'; value = parseFloat(target.value); beforeValue = light.shadow.normalBias; isShadowProperty = true; } if (property !== undefined && value !== beforeValue) { const isFinalChange = event.type === 'change'; if (property === 'castShadow' && value === true) { const currentShadowCasters = pointLights.filter(pl => pl.light.castShadow).length; const countExcludingCurrent = pointLights.filter(pl => pl.light.castShadow && pl.light !== light).length; if (countExcludingCurrent >= MAX_SHADOW_CASTING_POINT_LIGHTS) { console.warn(`מגבלת מנורות מטילות צל (${MAX_SHADOW_CASTING_POINT_LIGHTS}) הושגה. לא ניתן להפעיל צל למנורה זו.`); target.checked = false; plCastShadowCheckbox.disabled = true; setTimeout(() => plCastShadowCheckbox.disabled = false, 100); return; } } if (isFinalChange) { addHistory({ type: 'lightProperty', light: light, property: property, isShadowProperty: isShadowProperty, before: beforeValue, after: value }); } if (property === 'color') { light.color.set(value); const helper = lastSelected.mesh; if (helper && helper.material) helper.material.color.set(value); } else if (isShadowProperty) { if (light.shadow.map) { light.shadow.map.dispose(); light.shadow.map = null; } light.shadow[property] = value; if(property === 'castShadow') light.castShadow = value; } else { light[property] = value; } if (property === 'distance') updateRangeIndicator(); } }
        function onDoubleClick(event) { event.stopPropagation(); const rect = renderer.domElement.getBoundingClientRect(); mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(mouse, camera); const intersectableObjects = sceneObjects.map(obj => obj.mesh); const intersects = raycaster.intersectObjects(intersectableObjects, false); if (intersects.length > 0) { let intersectedSceneObject = null; for (const intersect of intersects) { intersectedSceneObject = sceneObjects.find(obj => obj.mesh === intersect.object); if (intersectedSceneObject) break; } if (intersectedSceneObject) { deselectObject(); selectObject(intersectedSceneObject, event); } } else { deselectObject(); closeSinglePanels(); } }


        // --- Selection and UI Update ---
        function showSingleObjectPanelBasedOnSelection() { closeSinglePanels(); if (selectedObjects.length === 1) { const lastSelected = selectedObjects[0]; if (lastSelected) { showSingleObjectPanel(lastSelected); } } }
        function showSingleObjectPanel(obj) {
            closeSinglePanels();
            const titleEl = document.getElementById('single-object-title-static');
            titleEl.textContent = obj.name;

            if (obj.isLightHelper) {
                // Handle light helper panel display
                if (obj.lightType === 'point') {
                    const light = lightHelpersMap.get(obj.mesh);
                    if (light) {
                        const plTitle = document.getElementById('point-light-title');
                        plTitle.textContent = obj.name.replace(' (Helper)', '');
                        plIntensitySlider.value = light.intensity;
                        plDistanceSlider.value = light.distance;
                        plIntensityValueSpan.textContent = light.intensity.toFixed(1);
                        plDistanceValueSpan.textContent = light.distance.toFixed(1);
                        plColorPicker.value = '#' + light.color.getHexString();
                        plCastShadowCheckbox.checked = light.castShadow;
                        plShadowBiasSlider.value = light.shadow.bias;
                        plShadowNormalBiasSlider.value = light.shadow.normalBias;
                        const currentShadowCasters = pointLights.filter(pl => pl.light.castShadow).length;
                        const canEnableShadow = light.castShadow || currentShadowCasters < MAX_SHADOW_CASTING_POINT_LIGHTS;
                        plCastShadowCheckbox.disabled = !canEnableShadow;
                        pointLightPanel.querySelector('.duplicate-btn').dataset.objectId = obj.id;
                        openPanel(pointLightPanel);
                    }
                }
            } else {
                // Handle regular object panel display
                const controlsContainer = document.getElementById('single-object-controls');
                let currentMaterial = getMaterialToChange(obj.mesh);
                if (Array.isArray(currentMaterial)) currentMaterial = currentMaterial[0]; // Use first material for UI values

                const startColor = currentMaterial ? currentMaterial.color.getHexString() : 'ffffff';
                const startRoughness = currentMaterial ? currentMaterial.roughness : 1;
                const startMetalness = currentMaterial ? currentMaterial.metalness : 0;
                const startOpacity = currentMaterial ? currentMaterial.opacity : 1;
                const startEmissiveIntensity = currentMaterial ? currentMaterial.emissiveIntensity : 0;
                const hasBump = currentMaterial && currentMaterial.bumpMap;

                const isChairModel = obj.parentModel && obj.parentModel.userData.url === CHAIR_MODEL_URL;
                const isKnessetPanel = obj.parentModel && obj.parentModel.userData.url === KNESSET_MODEL_URL && obj.name === 'פאנל LED';
                let materialControlsHtml = '';
                let chairControlsHtml = '';

                if (!isChairModel) {
                     materialControlsHtml = `
                        <button class="revert-btn w-full px-3 py-1 text-sm bg-yellow-600 hover:bg-yellow-700 rounded text-white transition-colors" data-object-id="${obj.id}">שחזר חומר לברירת מחדל</button>
                        <hr class="border-gray-600">
                        <h4 class="font-semibold text-gray-200">בקרת חומרים</h4>
                        <div><label for="color-${obj.id}" class="text-sm text-gray-300">צבע בסיס</label><input type="color" class="material-control color-picker w-full h-10 p-1 bg-gray-700 border border-gray-600 rounded cursor-pointer" id="color-${obj.id}" data-object-id="${obj.id}" value="#${startColor}"></div>
                        <div><label for="roughness-${obj.id}" class="text-sm text-gray-300">חספוס (ברק: 0 = מבריק, 1 = מט)</label><input type="range" class="material-control roughness-slider w-full" id="roughness-${obj.id}" data-object-id="${obj.id}" min="0" max="1" step="0.01" value="${startRoughness}"></div>
                        <div><label for="metalness-${obj.id}" class="text-sm text-gray-300">מתכתיות</label><input type="range" class="material-control metalness-slider w-full" id="metalness-${obj.id}" data-object-id="${obj.id}" min="0" max="1" step="0.01" value="${startMetalness}"></div>
                        <div><label for="opacity-${obj.id}" class="text-sm text-gray-300">שקיפות (0 = שקוף, 1 = אטום)</label><input type="range" class="material-control opacity-slider w-full" id="opacity-${obj.id}" data-object-id="${obj.id}" min="0" max="1" step="0.01" value="${startOpacity}"></div>
                        ${isKnessetPanel ? `<div><label for="emissive-${obj.id}" class="text-sm text-gray-300">עוצמת פליטה</label><input type="range" class="material-control emissive-intensity-slider w-full" id="emissive-${obj.id}" data-object-id="${obj.id}" min="0" max="5" step="0.1" value="${startEmissiveIntensity}"></div>` : ''}
                        <hr class="border-gray-600">
                        <div><label for="upload-single-${obj.id}" class="text-sm text-gray-300">טקסטורת צבע (Diffuse)</label><input type="file" class="texture-upload-input" id="upload-single-${obj.id}" data-object-id="${obj.id}" accept="image/*"></div>
                        <div><label for="bump-upload-${obj.id}" class="text-sm text-gray-300">טקסטורת בליטות (Bump) ${hasBump ? '<span class="text-green-400">(טעון)</span>' : ''}</label><input type="file" class="bump-upload-input" id="bump-upload-${obj.id}" data-object-id="${obj.id}" accept="image/*"></div>
                    `;
                } else {
                    chairControlsHtml = `
                        <button class="chair-camera-btn w-full px-3 py-1 text-sm bg-purple-600 hover:bg-purple-700 rounded text-white transition-colors mt-2" data-object-id="${obj.id}">מבט מצלמה</button>
                    `;
                }


                controlsContainer.innerHTML = `
                    <div class="space-y-4">
                        <button class="duplicate-btn w-full px-3 py-1 text-sm bg-blue-600 hover:bg-blue-700 rounded text-white transition-colors" data-object-id="${obj.id}" ${obj.mesh.userData.isLocked ? 'disabled' : ''}>שכפל מודל</button>
                        ${chairControlsHtml}
                        ${materialControlsHtml}
                    </div>`;

                openPanel(singleObjectPanel);
            }
        }
        function selectObject(sceneObjectData, event) {
             const isCtrlClick = event.ctrlKey || event.metaKey;
             const isSelected = selectedObjects.includes(sceneObjectData);

             if (isCtrlClick) {
                 if (isSelected) { selectedObjects = selectedObjects.filter(obj => obj !== sceneObjectData); }
                 else { selectedObjects.push(sceneObjectData); }
             } else {
                 if (!(selectedObjects.length === 1 && isSelected)) {
                     deselectObject();
                     selectedObjects = [sceneObjectData];
                 }
             }

            updateSelectionHighlight();

            if (selectedObjects.length > 0) {
                 const lastSelected = selectedObjects[selectedObjects.length - 1];
                 const objectToAttachTo = lastSelected.parentModel || lastSelected.mesh;
                 const isLocked = lastSelected.mesh.userData.isLocked;

                if (objectToAttachTo && !isLocked) {
                     transformControls.attach(objectToAttachTo);
                 } else {
                     transformControls.detach();
                 }

                if (lastSelected.isLightHelper && lastSelected.lightType === 'point') { createOrUpdateRangeIndicator(); }
                else { removeRangeIndicator(); }
                 showSingleObjectPanelBasedOnSelection();
            } else {
                 deselectObject();
            }
        }
        function deselectObject() { removeRangeIndicator(); selectedObjects = []; transformControls.detach(); updateSelectionHighlight(); closeSinglePanels(); }
        function updateSelectionHighlight() { document.querySelectorAll('#object-list .object-item').forEach(item => { const objectId = item.dataset.objectId; const sceneObj = sceneObjects.find(obj => obj.id === objectId); item.classList.toggle('selected-object', sceneObj && selectedObjects.includes(sceneObj)); }); document.querySelectorAll('#light-list .light-item').forEach(item => { const objectId = item.dataset.objectId; const sceneObj = sceneObjects.find(obj => obj.id === objectId); item.classList.toggle('selected-object', sceneObj && selectedObjects.includes(sceneObj)); }); }

        // --- Range Indicator ---
        function createOrUpdateRangeIndicator() { if (selectedObjects.length === 0) return; const lastSelected = selectedObjects[selectedObjects.length - 1]; if (!lastSelected || !lastSelected.isLightHelper || lastSelected.lightType !== 'point') { removeRangeIndicator(); return; } const light = lightHelpersMap.get(lastSelected.mesh); if (!light) return; if (!lightRangeIndicator) { const geometry = new THREE.SphereGeometry(1, 32, 16); const material = new THREE.MeshBasicMaterial({ color: 0xFF8C00, wireframe: true, transparent: true, opacity: 0.3 }); lightRangeIndicator = new THREE.Mesh(geometry, material); scene.add(lightRangeIndicator); } lightRangeIndicator.position.copy(lastSelected.mesh.position); lightRangeIndicator.scale.setScalar(light.distance); lightRangeIndicator.visible = true; }
        function updateRangeIndicator() { if (selectedObjects.length === 0) return; const lastSelected = selectedObjects[selectedObjects.length - 1]; if (lightRangeIndicator && lastSelected && lastSelected.isLightHelper && lastSelected.lightType === 'point') { const light = lightHelpersMap.get(lastSelected.mesh); if (light) { lightRangeIndicator.position.copy(lastSelected.mesh.position); lightRangeIndicator.scale.setScalar(light.distance); } } }
        function removeRangeIndicator() { if (lightRangeIndicator) lightRangeIndicator.visible = false; }

        // --- Utility Functions ---
        function setGizmoMode(mode) { transformControls.setMode(mode); gizmoButtons.forEach(btn => btn.classList.remove('active')); if (mode === 'translate') translateBtn.classList.add('active'); if (mode === 'rotate') rotateBtn.classList.add('active'); if (mode === 'scale') scaleBtn.classList.add('active'); }

        function toggleLightHelpers() {
            areLightHelpersVisible = !areLightHelpersVisible;

            pointLights.forEach(pl => {
                if (pl.helper) {
                    pl.helper.visible = areLightHelpersVisible;
                }
            });

            toggleLightHelpersBtn.classList.toggle('active', areLightHelpersVisible);
        }

        function makeDraggable(panel) {
            // השבתת גרירה במובייל
            if (window.innerWidth < 768) return;

            const handle = panel.querySelector('.draggable-handle');
            if (!handle) return;
            let isDragging = false, offsetX, offsetY;
            const topMenuBar = document.getElementById('top-menu-bar');

            handle.addEventListener('mousedown', (e) => {
                if (e.target.closest('button, input, label, select')) return;
                e.preventDefault();
                isDragging = true;
                const panelRect = panel.getBoundingClientRect();
                offsetX = e.clientX - panelRect.left;
                offsetY = e.clientY - panelRect.top;
                panel.style.right = 'auto';
                panel.style.transform = '';
                panel.style.left = `${panelRect.left}px`;
                panel.style.top = `${panelRect.top}px`;
                document.body.style.userSelect = 'none';
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });

            function onMouseMove(e) {
                if (!isDragging) return;
                let newX = e.clientX - offsetX;
                let newY = e.clientY - offsetY;
                const panelRect = panel.getBoundingClientRect();
                const menuBarHeight = topMenuBar ? topMenuBar.offsetHeight : 0;
                const topLimit = menuBarHeight + 10;

                newX = Math.max(0, Math.min(newX, window.innerWidth - panelRect.width));
                newY = Math.max(topLimit, Math.min(newY, window.innerHeight - panelRect.height));

                panel.style.left = `${newX}px`;
                panel.style.top = `${newY}px`;
            }

            function onMouseUp() {
                if (isDragging) {
                    isDragging = false;
                    document.body.style.userSelect = '';
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }
            }
        }
        function getMaterialToChange(mesh) { let material = mesh.material; if (!material) { console.warn("getMaterialToChange: No material found on mesh.", mesh); return null; } if (Array.isArray(material)) material.forEach(mat => { if (!mat.userData) mat.userData = {}; }); else if (!material.userData) material.userData = {}; return material; }

        // --- Material & Texture Application (Async) ---
        async function applyTextureFromDataUrl(sceneObject, dataUrl, addToHistory = true) { const mesh = sceneObject.mesh; if (!mesh) return; const materialToChange = getMaterialToChange(mesh); if (!materialToChange) return; if (addToHistory) { const firstMat = Array.isArray(materialToChange) ? materialToChange[0] : materialToChange; const beforeValue = firstMat.userData.textureDataUrl || null; if (beforeValue !== dataUrl) addHistory({ type: 'material', mesh: sceneObject.mesh, property: 'map', before: beforeValue, after: dataUrl }); } return new Promise((resolve, reject) => { textureLoader.load(dataUrl, (texture) => { texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; texture.repeat.set(4, 4); texture.colorSpace = THREE.SRGBColorSpace; const dataUrlToSave = dataUrl; const applyToMaterial = (mat) => { mat.map = texture.clone(); if (dataUrl) mat.color.set(0xffffff); mat.userData.textureDataUrl = dataUrlToSave; mat.needsUpdate = true; }; if (Array.isArray(materialToChange)) materialToChange.forEach(applyToMaterial); else applyToMaterial(materialToChange); resolve(); }, undefined, (err) => { console.error('Error loading texture from Data URL:', err); reject(err); }); }); }
        async function applyBumpMapFromDataUrl(sceneObject, dataUrl, addToHistory = true) { const mesh = sceneObject.mesh; if (!mesh) return; const materialToChange = getMaterialToChange(mesh); if (!materialToChange) return; if (addToHistory) { const firstMat = Array.isArray(materialToChange) ? materialToChange[0] : materialToChange; const beforeValue = firstMat.userData.bumpDataUrl || null; if (beforeValue !== dataUrl) addHistory({ type: 'material', mesh: sceneObject.mesh, property: 'bumpMap', before: beforeValue, after: dataUrl }); } return new Promise((resolve, reject) => { textureLoader.load(dataUrl, (texture) => { texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; const dataUrlToSave = dataUrl; const applyToMaterial = (mat) => { mat.bumpMap = texture.clone(); mat.bumpScale = 0.05; mat.userData.bumpDataUrl = dataUrlToSave; mat.needsUpdate = true; }; if (Array.isArray(materialToChange)) materialToChange.forEach(applyToMaterial); else applyToMaterial(materialToChange); if (selectedObjects.includes(sceneObject)) showSingleObjectPanelBasedOnSelection(); resolve(); }, undefined, (err) => { console.error('Error loading bump map from Data URL:', err); reject(err); }); }); }
        function revertToDefault(sceneObject, addToHistory = true) {
            const mesh = sceneObject.mesh;
            if (!mesh) return;
            const materialToChange = getMaterialToChange(mesh);
            const originalMaterial = sceneObject.originalMaterial;
            if (!materialToChange || !originalMaterial) return;

            if (addToHistory) {
                const firstMat = Array.isArray(materialToChange) ? materialToChange[0] : materialToChange;
                const beforeState = {
                    color: '#' + firstMat.color.getHexString(),
                    roughness: firstMat.roughness,
                    metalness: firstMat.metalness,
                    opacity: firstMat.opacity,
                    emissiveIntensity: firstMat.emissiveIntensity,
                    map: firstMat.userData.textureDataUrl || null,
                    bumpMap: firstMat.userData.bumpDataUrl || null
                };
                const originalFirstMat = Array.isArray(originalMaterial) ? originalMaterial[0] : originalMaterial;
                const afterEmissiveIntensity = (sceneObject.name === 'פאנל LED') ? 1.5 : (originalFirstMat.emissiveIntensity || 0);
                const afterState = {
                    color: '#' + originalFirstMat.color.getHexString(),
                    roughness: originalFirstMat.roughness,
                    metalness: originalFirstMat.metalness,
                    opacity: originalFirstMat.opacity,
                    emissiveIntensity: afterEmissiveIntensity,
                    map: originalFirstMat.map ? (originalFirstMat.map.image ? originalFirstMat.map.image.src : null) : null,
                    bumpMap: originalFirstMat.bumpMap ? (originalFirstMat.bumpMap.image ? originalFirstMat.bumpMap.image.src : null) : null
                };
                addHistory({ type: 'materialRevert', mesh: sceneObject.mesh, before: beforeState, after: afterState });
            }

            const applyRevert = (matToChange, matOriginal) => {
                if (!matOriginal) return;
                matToChange.map = matOriginal.map ? matOriginal.map.clone() : null;
                matToChange.color.set(matOriginal.color);
                matToChange.metalness = matOriginal.metalness;
                matToChange.roughness = matOriginal.roughness;
                matToChange.opacity = matOriginal.opacity;
                matToChange.transparent = matOriginal.opacity < 1;
                 const defaultIntensity = (sceneObject.name === 'פאנל LED') ? 1.5 : (matOriginal.emissiveIntensity || 0);
                 matToChange.emissiveIntensity = defaultIntensity;
                 if (sceneObject.name === 'פאנל LED') {
                     matToChange.emissive.setHex(0xFF0000);
                     matToChange.color.setHex(0x330000);
                 } else {
                     matToChange.emissive.set(matOriginal.emissive);
                 }
                matToChange.userData.textureDataUrl = null;
                matToChange.bumpMap = matOriginal.bumpMap ? matOriginal.bumpMap.clone() : null;
                matToChange.bumpScale = matOriginal.bumpScale || 1;
                matToChange.userData.bumpDataUrl = null;
                matToChange.needsUpdate = true;
            };

            if (Array.isArray(materialToChange)) {
                if (Array.isArray(originalMaterial))
                    for (let i = 0; i < materialToChange.length; i++) applyRevert(materialToChange[i], originalMaterial[i]);
            } else {
                const mat = Array.isArray(originalMaterial) ? originalMaterial[0] : originalMaterial;
                applyRevert(materialToChange, mat);
            }
        }

        // --- Duplication & Deletion ---
        function duplicateModel(objectId, addToHistory = true) {
            const targetObject = sceneObjects.find(obj => obj.id === objectId);
            if (!targetObject || !targetObject.parentModel || targetObject.mesh.userData.isLocked) {
                 console.warn("Cannot duplicate locked model or invalid object ID.");
                 return;
            }
            const originalModel = targetObject.parentModel;
            const newModel = originalModel.clone();
            newModel.position.add(new THREE.Vector3(1, 0, 1));
            newModel.userData.url = originalModel.userData.url;
            newModel.userData.initialOptions = originalModel.userData.initialOptions;
            newModel.userData.transform = { position: newModel.position.clone(), rotation: newModel.rotation.clone(), scale: newModel.scale.clone() };
            newModel.userData.isLocked = originalModel.userData.isLocked;
            const newSceneObjects = [];
            newModel.traverse((child) => {
                if (child.isMesh) {
                    child.userData.isLocked = newModel.userData.isLocked;
                    let originalChild = null;
                    originalModel.traverse(orig => { if (orig.isMesh && orig.userData.stableId === child.userData.stableId) originalChild = orig; });
                     if (!originalChild) originalModel.traverse(orig => { if (orig.isMesh && orig.name === child.name) originalChild = orig; }); if (!originalChild) originalModel.traverse(orig => { if (orig.isMesh && orig.material.uuid === child.material.uuid) originalChild = orig; });
                    const originalSceneObject = sceneObjects.find(obj => obj.mesh === originalChild);
                    let originalMaterialToClone = originalSceneObject ? getMaterialToChange(originalSceneObject.mesh) : child.material;
                    let newMaterial = Array.isArray(originalMaterialToClone) ? originalMaterialToClone.map(mat => mat.clone()) : originalMaterialToClone.clone();
                    child.material = newMaterial;
                    child.userData.stableId = originalSceneObject ? originalSceneObject.stableId : child.uuid;
                    const newSceneObject = {
                        id: child.uuid, stableId: child.userData.stableId, name: originalSceneObject ? `${originalSceneObject.name} (עותק)` : `חלק_${globalObjectCounter++}`,
                        mesh: child,
                        originalMaterial: originalSceneObject ? (Array.isArray(originalSceneObject.originalMaterial) ? originalSceneObject.originalMaterial.map(m => m.clone()) : originalSceneObject.originalMaterial.clone()) : (Array.isArray(child.material) ? child.material.map(m => m.clone()) : child.material.clone()),
                        parentModel: newModel
                    };
                    sceneObjects.push(newSceneObject);
                    newSceneObjects.push(newSceneObject);
                }
            });
            scene.add(newModel);

            if (sittingClapAnimation && originalModel.userData.mixer) {
                playAnimationOnModel(newModel, sittingClapAnimation);
            }

            if (addToHistory) addHistory({ type: 'duplicate', newModel: newModel, newSceneObjects: newSceneObjects });
            populateSidebar();
        }
        function duplicateLight(lightHelperObject, addToHistory = true) { const originalLight = lightHelpersMap.get(lightHelperObject.mesh); if (!originalLight) return; const newPosition = lightHelperObject.mesh.position.clone().add(new THREE.Vector3(1, 0, 1)); let newLightData; if (lightHelperObject.lightType === 'point') newLightData = createPointLight(newPosition, originalLight.intensity, originalLight.distance, originalLight.color, originalLight.castShadow, originalLight.shadow.bias, originalLight.shadow.normalBias); if (newLightData && addToHistory) addHistory({ type: 'duplicateLight', lightType: lightHelperObject.lightType, newLight: newLightData.light, newHelper: newLightData.helper, newSceneObjectData: newLightData.data }); }

        function deleteSelected(addToHistory = true) {
            if (selectedObjects.length === 0) return;
            const deletedModels = [];
            const deletedSceneObjectsGroups = [];
            const deletedLights = [];
            const deletedHelpers = [];
            const deletedLightSceneObjects = [];

            [...selectedObjects].forEach(objectToDeleteData => {
                if (objectToDeleteData.isLightHelper) {
                    const light = lightHelpersMap.get(objectToDeleteData.mesh);
                    if (light) {
                        deletedLights.push(light);
                        deletedHelpers.push(objectToDeleteData.mesh);
                        deletedLightSceneObjects.push(objectToDeleteData);
                        scene.remove(light);
                        scene.remove(objectToDeleteData.mesh);
                        lightHelpersMap.delete(objectToDeleteData.mesh);
                        sceneObjects = sceneObjects.filter(obj => obj !== objectToDeleteData);
                        if(objectToDeleteData.lightType === 'point') pointLights = pointLights.filter(pl => pl.helper !== objectToDeleteData.mesh);
                    }
                } else {
                    const parentModel = objectToDeleteData.parentModel;
                    if (parentModel && !deletedModels.includes(parentModel) && !parentModel.userData.isLocked) {
                        deletedModels.push(parentModel);
                        const objectsInModel = sceneObjects.filter(obj => obj.parentModel === parentModel);
                        deletedSceneObjectsGroups.push(objectsInModel);
                        scene.remove(parentModel);

                        if (parentModel.userData.mixer) {
                            parentModel.userData.mixer.stopAllAction();
                            mixers = mixers.filter(m => m !== parentModel.userData.mixer);
                        }

                        sceneObjects = sceneObjects.filter(obj => obj.parentModel !== parentModel);
                    } else if (parentModel && parentModel.userData.isLocked) {
                        console.warn("Cannot delete locked model:", parentModel.name || parentModel.uuid);
                    }
                }
            });

            if (addToHistory && (deletedModels.length > 0 || deletedLights.length > 0)) {
                addHistory({ type: 'deleteMultiple', deletedModels, deletedSceneObjectsGroups, deletedLights, deletedHelpers, deletedLightSceneObjects });
            }
            deselectObject();
            populateSidebar();
            populateLightList();
        }

        // --- Keyboard Shortcuts ---
        function onKeyDown(event) {
            const activeEl = document.activeElement;
            if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.tagName === 'SELECT')) return;

            if (event.shiftKey && event.key.toLowerCase() === 'd') {
                event.preventDefault();
                if (selectedObjects.length > 0) {
                    const uniqueModelsToDuplicate = new Set();
                    const lightHelpersToDuplicate = [];

                    selectedObjects.forEach(selectedObj => {
                        if (selectedObj.isLightHelper) {
                            lightHelpersToDuplicate.push(selectedObj);
                        } else if (selectedObj.parentModel && !selectedObj.mesh.userData.isLocked) {
                            uniqueModelsToDuplicate.add(selectedObj.parentModel);
                        }
                    });

                    uniqueModelsToDuplicate.forEach(model => {
                        const sceneObject = sceneObjects.find(obj => obj.parentModel === model);
                        if(sceneObject) duplicateModel(sceneObject.id);
                    });

                    lightHelpersToDuplicate.forEach(lightHelper => {
                        duplicateLight(lightHelper);
                    });
                }
                return;
            }

            if (event.ctrlKey || event.metaKey) {
                if (event.key.toLowerCase() === 'z') {
                    event.preventDefault();
                    undo();
                } else if (event.key.toLowerCase() === 'y') {
                    event.preventDefault();
                    redo();
                }
                return;
            }

            switch (event.key.toLowerCase()) {
                case 'z': case 'ז':
                    event.preventDefault();
                    zoomToSelected();
                    break;
                case 'w': case '׳':
                    event.preventDefault();
                    setGizmoMode('translate');
                    break;
                case 'e': case 'ק':
                    event.preventDefault();
                    setGizmoMode('rotate');
                    break;
                case 'r': case 'ר':
                    event.preventDefault();
                    setGizmoMode('scale');
                    break;
                case 'delete': case 'backspace':
                    event.preventDefault();
                    deleteSelected();
                    break;
            }
        }

        // --- Zoom Function ---
        function zoomToSelected() { if (selectedObjects.length === 0) return; const box = new THREE.Box3(); selectedObjects.forEach(selectedObj => { const objectToMeasure = selectedObj.parentModel || selectedObj.mesh; if (objectToMeasure) { box.expandByObject(objectToMeasure); } }); if (box.isEmpty()) return; const targetLookAt = box.getCenter(new THREE.Vector3()); const size = box.getSize(new THREE.Vector3()); const maxDim = Math.max(size.x, size.y, size.z); const distance = Math.max(maxDim * 2.5, 5); const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize(); const targetPosition = new THREE.Vector3().addVectors(targetLookAt, direction.multiplyScalar(distance)); const duration = 500; new TWEEN.Tween(camera.position).to(targetPosition, duration).easing(TWEEN.Easing.Quadratic.Out).start(); new TWEEN.Tween(controls.target).to(targetLookAt, duration).easing(TWEEN.Easing.Quadratic.Out).start(); }

         function focusCameraOnChair(chairObjectData) {
             const chairModel = chairObjectData.parentModel;
             if (!chairModel) return;

             const transform = chairModel.userData.transform || { position: chairModel.position, rotation: chairModel.rotation, scale: chairModel.scale };

             const box = new THREE.Box3().setFromObject(chairModel);
             const center = box.getCenter(new THREE.Vector3());
             const size = box.getSize(new THREE.Vector3());

             const offset = new THREE.Vector3(0, size.y * 0.4, -size.z * 1.2);
             const rotationQuaternion = new THREE.Quaternion().setFromEuler(transform.rotation);
             offset.applyQuaternion(rotationQuaternion);
             const targetPosition = center.clone().add(offset);

             const lookAtOffset = new THREE.Vector3(0, size.y * 0.1, size.z * 2);
             lookAtOffset.applyQuaternion(rotationQuaternion);
             const targetLookAt = center.clone().add(lookAtOffset);


             const duration = 700;
             new TWEEN.Tween(camera.position)
                 .to(targetPosition, duration)
                 .easing(TWEEN.Easing.Quadratic.Out)
                 .start();
             new TWEEN.Tween(controls.target)
                 .to(targetLookAt, duration)
                 .easing(TWEEN.Easing.Quadratic.Out)
                 .start();
         }


        // --- History Management ---
        function addHistory(action) { history = history.slice(0, historyIndex + 1); history.push(action); if (history.length > MAX_HISTORY) history.shift(); historyIndex = history.length - 1; updateHistoryButtons(); }
        function updateHistoryButtons() { undoBtn.disabled = historyIndex < 0; redoBtn.disabled = historyIndex >= history.length - 1; }
        function undo() { if (historyIndex < 0) return; const action = history[historyIndex]; applyAction(action, 'before'); historyIndex--; updateHistoryButtons(); }
        function redo() { if (historyIndex >= history.length - 1) return; historyIndex++; const action = history[historyIndex]; applyAction(action, 'after'); updateHistoryButtons(); }
        function applyAction(action, state) {
            const data = action[state];
            switch(action.type) {
                case 'transform': {
                    const obj = action.object;
                    obj.position.copy(data.position);
                    obj.rotation.copy(data.rotation);
                    obj.scale.copy(data.scale);
                    if(obj.userData.transform) {
                        obj.userData.transform.position.copy(data.position);
                        obj.userData.transform.rotation.copy(data.rotation);
                        obj.userData.transform.scale.copy(data.scale);
                    }
                    const actualLight = lightHelpersMap.get(obj);
                    if (actualLight) {
                        actualLight.position.copy(obj.position);
                        updateRangeIndicator();
                    }
                    break;
                }
                case 'material': {
                    const material = getMaterialToChange(action.mesh);
                    const sceneObject = sceneObjects.find(obj => obj.mesh === action.mesh);
                    const applyToMat = (mat) => {
                        switch(action.property) {
                            case 'color':
                                mat.color.set(data);
                                mat.map = null;
                                mat.userData.textureDataUrl = null;
                                break;
                            case 'roughness':
                                mat.roughness = data;
                                break;
                            case 'metalness':
                                mat.metalness = data;
                                break;
                            case 'opacity':
                                mat.opacity = data;
                                mat.transparent = data < 1;
                                break;
                            case 'emissiveIntensity':
                                 mat.emissiveIntensity = data;
                                 break;
                            case 'map':
                                if (data) applyTextureFromDataUrl(sceneObject, data, false);
                                else { mat.map = null; mat.userData.textureDataUrl = null; }
                                break;
                            case 'bumpMap':
                                if (data) applyBumpMapFromDataUrl(sceneObject, data, false);
                                else { mat.bumpMap = null; mat.userData.bumpDataUrl = null; }
                                break;
                        }
                        mat.needsUpdate = true;
                    };
                    if (Array.isArray(material)) material.forEach(applyToMat);
                    else applyToMat(material);
                    if (selectedObjects.includes(sceneObject)) showSingleObjectPanelBasedOnSelection();
                    break;
                }
                case 'materialRevert': {
                    const material = getMaterialToChange(action.mesh);
                    const sceneObject = sceneObjects.find(obj => obj.mesh === action.mesh);
                    const applyToMat = (mat) => {
                        mat.color.set(data.color);
                        mat.roughness = data.roughness;
                        mat.metalness = data.metalness;
                        mat.opacity = data.opacity;
                        mat.transparent = data.opacity < 1;
                        mat.emissiveIntensity = data.emissiveIntensity;
                         if (sceneObject.name === 'פאנל LED') {
                             mat.emissive.setHex(0xFF0000);
                         } else {
                             // mat.emissive.set(originalEmissiveColor);
                         }
                        mat.needsUpdate = true;
                    };
                    if (Array.isArray(material)) material.forEach(applyToMat);
                    else applyToMat(material);
                    // Handle map and bumpMap separately as they are async
                    if (data.map) applyTextureFromDataUrl(sceneObject, data.map, false);
                    else {
                        if (Array.isArray(material)) material.forEach(m => { m.map = null; m.userData.textureDataUrl = null; });
                        else { material.map = null; material.userData.textureDataUrl = null; }
                    }
                    if (data.bumpMap) applyBumpMapFromDataUrl(sceneObject, data.bumpMap, false);
                    else {
                        if (Array.isArray(material)) material.forEach(m => { m.bumpMap = null; m.userData.bumpDataUrl = null; });
                        else { material.bumpMap = null; material.userData.bumpDataUrl = null; }
                    }
                    if (selectedObjects.includes(sceneObject)) showSingleObjectPanelBasedOnSelection();
                    break;
                }
                case 'duplicate': {
                    if (state === 'after') {
                        scene.add(action.newModel);
                        sceneObjects.push(...action.newSceneObjects);
                        if (sittingClapAnimation && action.newModel.userData.url.endsWith('.fbx')) {
                            playAnimationOnModel(action.newModel, sittingClapAnimation);
                        }
                    } else {
                        scene.remove(action.newModel);
                        if (action.newModel.userData.mixer) {
                            action.newModel.userData.mixer.stopAllAction();
                            mixers = mixers.filter(m => m !== action.newModel.userData.mixer);
                        }
                        sceneObjects = sceneObjects.filter(obj => !action.newSceneObjects.includes(obj));
                    }
                    populateSidebar();
                    break;
                }
                case 'duplicateLight': {
                    if (state === 'after') {
                        scene.add(action.newLight);
                        scene.add(action.newHelper);
                        lightHelpersMap.set(action.newHelper, action.newLight);
                        sceneObjects.push(action.newSceneObjectData);
                        if(action.lightType === 'point') pointLights.push({ light: action.newLight, helper: action.newHelper, data: action.newSceneObjectData });
                    } else {
                        scene.remove(action.newLight);
                        scene.remove(action.newHelper);
                        lightHelpersMap.delete(action.newHelper);
                        sceneObjects = sceneObjects.filter(obj => obj !== action.newSceneObjectData);
                        if(action.lightType === 'point') pointLights = pointLights.filter(pl => pl.helper !== action.newHelper);
                    }
                    populateLightList();
                    break;
                }
                case 'lightProperty': {
                    const light = action.light;
                    if (action.property === 'color') {
                        light.color.set(data);
                        const helper = pointLights.find(pl => pl.light === light)?.helper;
                        if (helper && helper.material) helper.material.color.set(data);
                    } else if (action.isShadowProperty) {
                        if (light.shadow.map) { light.shadow.map.dispose(); light.shadow.map = null; }
                        light.shadow[action.property] = data;
                        if(action.property === 'castShadow') light.castShadow = data;
                    } else {
                        light[action.property] = data; // Use action.property here
                    }
                    const lastSelected = selectedObjects.length > 0 ? selectedObjects[selectedObjects.length - 1] : null;
                    if (lastSelected && lightHelpersMap.get(lastSelected.mesh) === light) {
                        if (action.property === 'intensity') { plIntensitySlider.value = data; plIntensityValueSpan.textContent = data.toFixed(1); }
                        else if (action.property === 'distance') { plDistanceSlider.value = data; plDistanceValueSpan.textContent = data.toFixed(1); updateRangeIndicator(); }
                        else if (action.property === 'color') { plColorPicker.value = data; }
                        else if (action.property === 'castShadow') { plCastShadowCheckbox.checked = data; }
                        else if (action.property === 'bias') { plShadowBiasSlider.value = data; }
                        else if (action.property === 'normalBias') { plShadowNormalBiasSlider.value = data; }
                    }
                    break;
                }
                case 'deleteMultiple': {
                    if (state === 'after') {
                        action.deletedModels.forEach(model => {
                            scene.remove(model);
                            if (model.userData.mixer) {
                                model.userData.mixer.stopAllAction();
                                mixers = mixers.filter(m => m !== model.userData.mixer);
                            }
                        });
                        action.deletedLights.forEach(light => scene.remove(light));
                        action.deletedHelpers.forEach(helper => {
                            scene.remove(helper);
                            lightHelpersMap.delete(helper);
                        });
                        sceneObjects = sceneObjects.filter(obj => !action.deletedSceneObjectsGroups.flat().includes(obj) && !action.deletedLightSceneObjects.includes(obj));
                        pointLights = pointLights.filter(pl => !action.deletedHelpers.includes(pl.helper));
                        deselectObject();
                    } else {
                        action.deletedModels.forEach(model => {
                            scene.add(model);
                            if (sittingClapAnimation && model.userData.url.endsWith('.fbx')) {
                                playAnimationOnModel(model, sittingClapAnimation);
                            }
                        });
                        action.deletedLights.forEach(light => scene.add(light));
                        action.deletedHelpers.forEach((helper, index) => {
                            scene.add(helper);
                            lightHelpersMap.set(helper, action.deletedLights[index]);
                        });
                        sceneObjects.push(...action.deletedSceneObjectsGroups.flat());
                        sceneObjects.push(...action.deletedLightSceneObjects);
                        action.deletedLightSceneObjects.forEach((lightSceneObj, index) => {
                            if(lightSceneObj.lightType === 'point') {
                                pointLights.push({ light: action.deletedLights[index], helper: action.deletedHelpers[index], data: lightSceneObj });
                            }
                        });
                    }
                    populateSidebar();
                    populateLightList();
                    break;
                }
                case 'addLight': {
                    if (state === 'after') {
                        scene.add(action.addedLight);
                        scene.add(action.addedHelper);
                        lightHelpersMap.set(action.addedHelper, action.addedLight);
                        sceneObjects.push(action.addedSceneObjectData);
                        if (action.lightType === 'point') pointLights.push({ light: action.addedLight, helper: action.addedHelper, data: action.addedSceneObjectData });
                    } else {
                        scene.remove(action.addedLight);
                        scene.remove(action.addedHelper);
                        lightHelpersMap.delete(action.addedHelper);
                        sceneObjects = sceneObjects.filter(obj => obj !== action.addedSceneObjectData);
                        if (action.lightType === 'point') pointLights = pointLights.filter(pl => pl.helper !== action.addedHelper);
                    }
                    populateLightList();
                    break;
                }
            }
        }

        // --- Save & Load ---
        function saveScene() {
            const sceneConfig = {
                pointLights: pointLights.map(pl => ({
                    intensity: pl.light.intensity,
                    distance: pl.light.distance,
                    position: pl.light.position.toArray(),
                    color: '#' + pl.light.color.getHexString(),
                    castShadow: pl.light.castShadow,
                    shadowBias: pl.light.shadow.bias,
                    shadowNormalBias: pl.light.shadow.normalBias
                })),
                 // [נמחק] effects שמירה
            };
            const models = [];
            const processedModels = new Set();
            sceneObjects.forEach(obj => {
                if (!obj.parentModel || obj.isLightHelper) return;
                if (processedModels.has(obj.parentModel.uuid)) return;

                const parentModel = obj.parentModel;
                const transformData = parentModel.userData.transform || { position: parentModel.position, rotation: parentModel.rotation, scale: parentModel.scale };
                const modelData = {
                    url: parentModel.userData.url,
                    transform: {
                        position: transformData.position.toArray(),
                        rotation: [transformData.rotation.x, transformData.rotation.y, transformData.rotation.z],
                        scale: transformData.scale.toArray()
                    },
                    materials: {},
                    hasAnimation: !!parentModel.userData.mixer
                };

                const childMeshes = sceneObjects.filter(o => o.parentModel === parentModel);
                childMeshes.forEach(childObj => {
                    const material = getMaterialToChange(childObj.mesh);
                    const firstMat = Array.isArray(material) ? material[0] : material;
                    if (firstMat) {
                        const isChairModel = childObj.parentModel && childObj.parentModel.userData.url === CHAIR_MODEL_URL;
                        if (!isChairModel) {
                            modelData.materials[childObj.stableId] = {
                                textureDataUrl: firstMat.userData.textureDataUrl || null,
                                bumpDataUrl: firstMat.userData.bumpDataUrl || null,
                                color: firstMat.color.getHexString(),
                                roughness: firstMat.roughness,
                                metalness: firstMat.metalness,
                                opacity: firstMat.opacity,
                                emissiveIntensity: firstMat.emissiveIntensity
                            };
                        }
                    }
                });
                models.push(modelData);
                processedModels.add(parentModel.uuid);
            });
            const finalData = { sceneConfig, models };
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(finalData));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "scene_state.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }
        async function loadScene(event) {
             const file = event.target.files[0];
             if (!file) return;
             const reader = new FileReader();
             reader.onload = async (e) => {
                 try {
                     const finalData = JSON.parse(e.target.result);
                     history = []; historyIndex = -1; updateHistoryButtons();
                     // Clear existing lights and non-helper objects
                     pointLights.forEach(pl => { scene.remove(pl.light); scene.remove(pl.helper); lightHelpersMap.delete(pl.helper); });
                     pointLights = [];
                     // We need to clear models here as well, let loadAllModels handle it.

                     const config = finalData.sceneConfig;
                     if (config) {
                         // Load Point Lights
                         if (config.pointLights && Array.isArray(config.pointLights)) {
                             config.pointLights.forEach(plData => {
                                 const color = plData.color ? plData.color : 0xffffff;
                                 const castShadow = plData.castShadow !== undefined ? plData.castShadow : false;
                                 const shadowBias = plData.shadowBias !== undefined ? plData.shadowBias : 0;
                                 const shadowNormalBias = plData.shadowNormalBias !== undefined ? plData.shadowNormalBias : 0.05;
                                 createPointLight( new THREE.Vector3().fromArray(plData.position), plData.intensity, plData.distance, color, castShadow, shadowBias, shadowNormalBias);
                             });
                         } else {
                             // Add default lights if none are loaded
                             if(pointLights.length === 0) {
                                 createPointLight(new THREE.Vector3(5, 15, 5), 100, 100, 0xffffff, true, 0, 0.05);
                                 createPointLight(new THREE.Vector3(-5, 15, 5), 100, 100, 0xffffff, true, 0, 0.05);
                                 // ... add other defaults if needed
                             }
                         }

                         // [נמחק] טעינת Bloom settings

                         scene.environment = null; scene.userData.hdriDataUrl = null; // Ensure HDRI is cleared

                     } else {
                          // Add default lights if no config exists
                         if(pointLights.length === 0) {
                             createPointLight(new THREE.Vector3(5, 15, 5), 100, 100, 0xffffff, true, 0, 0.05);
                            createPointLight(new THREE.Vector3(-5, 15, 5), 100, 100, 0xffffff, true, 0, 0.05);
                             // ... add other defaults if needed
                         }
                         // [נמחק] Reset bloom to default if no config exists
                     }
                     await loadAllModels(finalData.models || []);

                 } catch (err) {
                     console.error("Error loading JSON file:", err);
                     alert("Error: Invalid scene file.");
                 }
             };
             reader.readAsText(file);
             event.target.value = null; // Reset file input
         }


        // --- Rendering Loop & Resize ---
        function onWindowResize() {
            const width = sceneContainer.clientWidth;
            const height = sceneContainer.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            composer.setSize(width, height);

            allPanels.forEach(panel => {
                 const oldHandle = panel.querySelector('.draggable-handle');
                 if (oldHandle && oldHandle._initDrag) {
                     // אין דרך פשוטה להסיר listener אנונימי, נסתמך על הבדיקה ב-makeDraggable
                 }
                 makeDraggable(panel);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();

            const delta = clock.getDelta();
            for ( const mixer of mixers ) {
                mixer.update( delta );
            }

            if (controls && knessetBounds) {
                const target = controls.target;
                const clampedX = THREE.MathUtils.clamp(target.x, knessetBounds.min.x + boundsPadding, knessetBounds.max.x - boundsPadding);
                const clampedZ = THREE.MathUtils.clamp(target.z, knessetBounds.min.z + boundsPadding, knessetBounds.max.z - boundsPadding);
                const clampedY = Math.max(target.y, 0.5);

                 if (target.x !== clampedX || target.z !== clampedZ || target.y !== clampedY) {
                     controls.target.set(clampedX, clampedY, clampedZ);
                 }
            }

            composer.render();
        }
    </script>
</body>
</html>

